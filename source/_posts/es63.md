---
title: 深入理解ES6（3）
date: 2018-03-22 17:31:37
categories: 学习笔记
---
### Promise与异步编程
#### Promise基础
1.Promise是为异步操作的结果所准备的占位符。函数可以返回一个Promise，而不必订阅一个事件或向函数传递一个回调参数。
<!-- more -->
2.then()方法在所有的 Promise 上都存在，并且接受两个参数。第一个参数是Promise被完成时要调用的函数，与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是Promise被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。传递给then()的两个参数都是可选的，因此你可以监听完成与拒绝的任意组合形式。
3.用这种方式实现then()法的任何对象都被称为一个thenable。所有的Promise都是thenable，反之则未必成立。
4.Promis也具有一个catch()方法，其行为等同于只传递拒绝处理函数给then()。
5.then()与catch()背后的意图是让你组合使用它们来正确处理异步操作的结果。此系统要优于事件与回调函数，因为它让操作是成功还是失败变得完全清晰（事件模式倾向于在出错时不被触发，而在回调函数模式中你必须始终记得检查错误参数）。只需知道若你未给Promise附加拒绝处理函数，所有的错误就会静默发生。建议始终附加一个拒绝处理函数，即使该处理程序只是用于打印错误日志。
6.即使完成或拒绝处理函数在Promise已经被解决之后才添加到作业队列，它们仍然会被执行。这允许你随时添加新的完成或拒绝处理函数，并保证它们会被调用。
{% codeblock %}
let promise = readFile("example.txt");
// 原始的完成处理函数
promise.then(function(contents) {
	console.log(contents);
	// 现在添加另一个
	promise.then(function(contents) {
		console.log(contents);
	});
});
{% endcodeblock %}
每次调用then()或catch()都会创建一个新的作业，它会在Promise已决议时被执行。但这些作业最终会进入一个完全为Promise保留的作业队列。这个独立队列的确切细节对于理解如何使用Promise是不重要的，你只需理解作业队列通常来说是如何工作的。

#### 创建未决的Promise
1.新的Promise使用Promise构造器来创建。此构造器接受单个参数：一个被称为执行器（executor）的函数，包含初始化Promise的代码。该执行器会被传递两个名为resolve()与reject()的函数作为参数。resolve()函数在执行器成功结束时被调用，用于示意该Promise已经准备好被决议（resolved），而reject()函数则表明执行器的操作已失败。
{% codeblock %}
// Node.js 范例
let fs = require("fs");
function readFile(filename) {
	return new Promise(function(resolve, reject) {
		// 触发异步操作
		fs.readFile(filename, { encoding: "utf8" }, function(err, contents) {
			// 检查错误
			if (err) {
				reject(err);
				return;
			}
			// 读取成功
			resolve(contents);
		});
	});
}
let promise = readFile("example.txt");
// 同时监听完成与拒绝
promise.then(function(contents) {
	// 完成
	console.log(contents);
}, function(err) {
	// 拒绝
	console.error(err.message);
});
/*
执行器会在readFile()被调用时立即运行。当resolve()或reject()在执行器内部被调用时，一个作业被添加到作业队列中，以便决议（resolve）这个 Promise 。这被称为作业调度（job scheduling），
*/
{% endcodeblock %}
2.Promise的执行器会立即执行，早于源代码中在其之后的任何代码。
{% codeblock %}
let promise = new Promise(function(resolve, reject) {
	console.log("Promise");
	resolve();
});
console.log("Hi!");

//此代码的输出结果为：
//Promise
//Hi!
{% endcodeblock %}
3.调用resolve()触发了一个异步操作。传递给then()与catch()的函数会异步地被执行，并且它们也被添加到了作业队列（先进队列再执行）。

#### 创建已决的Promise
1.使用Promise.resolve()
Promise.resolve()方法接受单个参数并会返回一个处于完成态的Promise。这意味着没有任何作业调度会发生，并且你需要向Promise添加一个或更多的完成处理函数来提取这个参数值。
{% codeblock %}
let promise = Promise.resolve(42);
promise.then(function(value) {
	console.log(value); // 42
});
{% endcodeblock %}
2.使用Promise.reject()
你也可以使用Promise.reject()方法来创建一个已拒绝的Promise。此方法像Promise.resolve()一样工作，区别是被创建的Promise处于拒绝态。
{% codeblock %}
let promise = Promise.reject(42);
promise.catch(function(value) {
	console.log(value); // 42
});
{% endcodeblock %}
对挂起态或完成态的Promise使用Promise.resolve()没问题，会返回原Promise；对拒绝态的Promise使用Promise.reject()也没问题。而除此之外的情况全都会在原Promise上包装出一个新的Promise。

#### 非Promise的Thenable
Promise.resolve()与Promise.reject()都能接受非Promise的thenable作为参数。当传入了非Promise的thenable时，这些方法会创建一个新的Promise，此Promise会在then()函数之后被调用。
当一个对象拥有一个能接受resolve与reject参数的then()方法，该对象就会被认为是一个非Promise的thenable
{% codeblock %}
let thenable = {
	then: function(resolve, reject) {
		resolve(42);
	}
};
let p1 = Promise.resolve(thenable);
p1.then(function(value) {
	console.log(value); // 42
});
/*
在此例中，Promise.resolve()调用了thenable.then()，确定了这个thenable的Promise状态：由于resolve(42)在thenable.then()方法内部被调用，这个thenable的Promise状态也就被设为已完成。一个名为p1的新Promise被创建为完成态，并从thenable中接收到了值（此处为42），于是p1的完成处理函数就接收到一个值为42的参数。
*/
{% endcodeblock %}

#### 执行器错误
如果在执行器内部抛出了错误，那么Promise的拒绝处理函数就会被调用。
执行器处理程序捕捉了抛出的任何错误，以简化这种常见处理。但在执行器内抛出的错误仅当存在拒绝处理函数时才会被报告，否则这个错误就会被隐瞒。
{% codeblock %}
let promise = new Promise(function(resolve, reject) {
	throw new Error("Explosion!");
});
promise.catch(function(error) {
	console.log(error.message); // "Explosion!"
});
{% endcodeblock %}

#### 全局的Promise拒绝处理
由于Promise的本质，判断一个Promise的拒绝是否已被处理并不直观。例如
{% codeblock %}
let rejected = Promise.reject(42);
// 在此刻 rejected 不会被处理
// 一段时间后……
rejected.catch(function(value) {
	// 现在 rejected 已经被处理了
	console.log(value);
});
{% endcodeblock %}
无论Promise是否已被解决，你都可以在任何时候调用then()或catch()并使它们正确工作，这导致很难准确知道一个Promise何时会被处理。此例中的Promise被立刻拒绝，但它后来才被处理。

##### Node.js的拒绝处理
在Node.js中，process对象上存在两个关联到Promise的拒绝处理的事件：
1.unhandledRejection：当一个Promise被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；
2.rejectionHandled：若一个Promise被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。
这两个事件旨在共同帮助识别已被拒绝但未曾被处理promise。
{% codeblock %}
let rejected;
process.on("unhandledRejection", function(reason, promise) {
	console.log(reason.message); // "Explosion!"
	console.log(rejected === promise); // true
});
rejected = Promise.reject(new Error("Explosion!"));
{% endcodeblock %}
{% codeblock %}
let rejected;
process.on("rejectionHandled", function(promise) {
	console.log(rejected === promise); // true
});
rejected = Promise.reject(new Error("Explosion!"));
// 延迟添加拒绝处理函数
setTimeout(function() {
	rejected.catch(function(value) {
		console.log(value.message); // "Explosion!"
	});
}, 1000)
/*
此处的rejectionHandled事件在拒绝处理函数最终被调用时触发。若在rejected被创建后直接将拒绝处理函数附加到它上面，那么此事件就不会被触发。因为立即附加的拒绝处理函数在rejected被创建的事件循环的同一个轮次内就会被调用，这样rejectionHandled就不会起作用。
*/
{% endcodeblock %}
为了正确追踪潜在的未被处理的拒绝，使用rejectionHandled与unhandledRejection事件就能保持包含这些Promise的一个列表，之后等待一段时间再检查此列表。
{% codeblock %}
let possiblyUnhandledRejections = new Map();
// 当一个拒绝未被处理，将其添加到 map
process.on("unhandledRejection", function(reason, promise) {
	possiblyUnhandledRejections.set(promise, reason);
});
process.on("rejectionHandled", function(promise) {
	possiblyUnhandledRejections.delete(promise);
});
setInterval(function() {
	possiblyUnhandledRejections.forEach(function(reason, promise) {
		console.log(reason.message ? reason.message : reason);
		// 做点事来处理这些拒绝
		handleRejection(promise, reason);
	});
	possiblyUnhandledRejections.clear();
}, 60000);
{% endcodeblock %}

##### 浏览器的拒绝处理
浏览器同样能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被window对象触发，并完全等效于Node.js的相关事件：
1.unhandledrejection：当一个Promise被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；
2.rejectionHandled：若一个Promise被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。
Node.js的实现会传递分离的参数给事件处理函数，而浏览器事件的处理函数则只会接收到包含下列属性的一个对象：
type：事件的名称（"unhandledrejection"或"rejectionhandled"）；
promise：被拒绝的Promise对象；
reason：Promise中的拒绝值（拒绝原因）。
浏览器的实现中存在的另一个差异就是：拒绝值（reason）在两种事件中都可用。
{% codeblock %}
let rejected;
window.onunhandledrejection = function(event) {
	console.log(event.type); // "unhandledrejection"
	console.log(event.reason.message); // "Explosion!"
	console.log(rejected === event.promise); // true
};
window.onrejectionhandled = function(event) {
	console.log(event.type); // "rejectionhandled"
	console.log(event.reason.message); // "Explosion!"
	console.log(rejected === event.promise); // true
};
rejected = Promise.reject(new Error("Explosion!"));
{% endcodeblock %}
{% codeblock %}
let possiblyUnhandledRejections = new Map();
// 当一个拒绝未被处理，将其添加到 map
window.onunhandledrejection = function(event) {
	possiblyUnhandledRejections.set(event.promise, event.reason);
};
window.onrejectionhandled = function(event) {
	possiblyUnhandledRejections.delete(event.promise);
};
setInterval(function() {
	possiblyUnhandledRejections.forEach(function(reason, promise) {
		console.log(reason.message ? reason.message : reason);
		// 做点事来处理这些拒绝
		handleRejection(promise, reason);
	});
	possiblyUnhandledRejections.clear();
}, 60000);
{% endcodeblock %}

##### 串联Promise
1.每次对then()或catch()的调用实际上创建并返回了另一个Promise，仅当前一个Promise被完成或拒绝时，后一个Promise才会被决议。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
p1.then(function(value) {
	console.log(value);
}).then(function() {
	console.log("Finished");
});
//42
//Finished
/*
对p1.then()的调用返回了第二个Promise，又在这之上调用了then()。仅当第一个Promise已被决议后，第二个then()的完成处理函数才会被调用。
*/
{% endcodeblock %}

##### 捕获错误
Promise链允许你捕获前一个Promise的完成或拒绝处理函数中发生的错误。为了确保能正确处理任意可能发生的错误，应当始终在Promise链尾部添加拒绝处理函数。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
p1.then(function(value) {
	throw new Error("Boom!");
}).catch(function(error) {
	console.log(error.message); // "Boom!"
});
{% endcodeblock %}

##### 在Promise链中返回值
Promise链的另一重要方面是能从一个Promise传递数据给下一个Promise的能力。传递给执行器中的resolve()处理函数的参数，会被传递给对应Promise的完成处理函数，这点你前面已看到过了。你可以指定完成处理函数的返回值，以便沿着一个链继续传递数据。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
p1.then(function(value) {
	console.log(value); // "42"
	return value + 1;
}).then(function(value) {
	console.log(value); // "43"
});
{% endcodeblock %}

##### 在Promise链中返回Promise
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
let p2 = new Promise(function(resolve, reject) {
	resolve(43);
});
p1.then(function(value) {
	// 第一个完成处理函数
	console.log(value); // 42
	return p2;
}).then(function(value) {
	// 第二个完成处理函数
	console.log(value); // 43
});
{% endcodeblock %}
关于此模式需认识的首要重点是第二个完成处理函数并未被添加到p2上，而是被添加到第三个Promise 。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
let p2 = new Promise(function(resolve, reject) {
	reject(43);
});
p1.then(function(value) {
	// 第一个完成处理函数
	console.log(value); // 42
	return p2;
}).then(function(value) {
	// 第二个完成处理函数
	console.log(value); // 永不被调用
});
//由于p2被拒绝了，第二个完成处理函数就永不被调用。
{% endcodeblock %}
从完成或拒绝处理函数中返回thenable，不会对Promise执行器何时被执行有所改变。第一个被定义的Promise将会首先运行它的执行器，接下来才轮到第二个Promise的执行器执行，以此类推。返回thenable只是让你能在Promise结果之外定义附加响应。你能通过在完成处理函数中创建一个新的Promise，来推迟完成处理函数的执行。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
p1.then(function(value) {
	console.log(value); // 42
	// 创建一个新的 promise
	let p2 = new Promise(function(resolve, reject) {
		resolve(43);
	});
	return p2
}).then(function(value) {
	console.log(value); // 43
});
{% endcodeblock %}
若你想等待前面的Promise被解决，之后才去触发另一个Promise，那么这种模式就非常有用。

#### 响应多个Promise

##### Promise.all()方法
Promise.all()方法接收单个可迭代对象（如数组）作为参数，并返回一个Promise。这个可迭代对象的元素都是Promise，只有在它们都完成后，所返回的Promise才会被完成。
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
let p2 = new Promise(function(resolve, reject) {
	resolve(43);
});
let p3 = new Promise(function(resolve, reject) {
	resolve(44);
});
let p4 = Promise.all([p1, p2, p3]);
p4.then(function(value) {
	console.log(Array.isArray(value)); // true
	console.log(value[0]); // 42
	console.log(value[1]); // 43
	console.log(value[2]); // 44
});
{% endcodeblock %}
此处前面的每个Promise都用一个数值进行了决议，对Promise.all()的调用创建了新的Promisep4，在p1、p2与p3都被完成后，p4最终会也被完成。传递给p4的完成处理函数的结果是一个包含每个决议值（42、43与44）的数组，这些值的存储顺序保持了待决议的Promise的顺序（与完成的先后顺序无关），因此你可以将结果匹配到每个Promise。
若传递给Promise.all()的任意Promise被拒绝了，那么方法所返回的Promise就会立刻被拒绝，而不必等待其他的Promise结束：
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
let p2 = new Promise(function(resolve, reject) {
	reject(43);
});
let p3 = new Promise(function(resolve, reject) {
	resolve(44);
});
let p4 = Promise.all([p1, p2, p3]);
p4.catch(function(value) {
	console.log(Array.isArray(value)) // false
	console.log(value); // 43
});
{% endcodeblock %}

##### Promise.race()方法
此方法也接受一个包含需监视的Promise的可迭代对象，并返回一个新的Promise，但一旦来源Promise中有一个被解决，所返回的Promise就会立刻被解决。
{% codeblock %}
let p1 = Promise.resolve(42);
let p2 = new Promise(function(resolve, reject) {
	resolve(43);
});
let p3 = new Promise(function(resolve, reject) {
	resolve(44);
});
let p4 = Promise.race([p1, p2, p3]);
p4.then(function(value) {
	console.log(value); // 42
});
{% endcodeblock %}
{% codeblock %}
let p1 = new Promise(function(resolve, reject) {
	resolve(42);
});
let p2 = Promise.reject(43);
let p3 = new Promise(function(resolve, reject) {
	resolve(44);
});
let p4 = Promise.race([p1, p2, p3]);
p4.catch(function(value) {
	console.log(value); // 43
});
/*
此处的p4被拒绝了，因为p2在Promise.race()被调用时已经处于拒绝态。尽管p1与p3都被完成，其结果仍然被忽略，因为这发生在p2被拒绝之后。
*/
{% endcodeblock %}

#### 继承Promise
正像其他内置类型，你可将一个Promise用作派生类的基类。这允许你自定义变异的Promise，在内置Promise的基础上扩展功能。
{% codeblock %}
class MyPromise extends Promise {
	// 使用默认构造器
	success(resolve, reject) {
		return this.then(resolve, reject);
	}
	failure(reject) {
		return this.catch(reject);
	}
}
let promise = new MyPromise(function(resolve, reject) {
	resolve(42);
});
promise.success(function(value) {
	console.log(value); // 42
}).failure(function(value) {
	console.log(value);
});
{% endcodeblock %}

#### 异步任务运行
async关键字标明了此函数使用异步方式运行。await关键字则表示对于readFile("config.json")的函数调用应返回一个Promise，若返回类型不对，则会将其包装为Promise。await会在Promise被拒绝的情况下抛出错误，否则它将返回该Promise被决议的值。
{% codeblock %}
let fs = require("fs");
function readFile(filename) {
	return new Promise(function(resolve, reject) {
		fs.readFile(filename, function(err, contents) {
			if (err) {
				reject(err);
			} else {
				resolve(contents);
			}
		});
	});
}

(async function() {
	let contents = await readFile("config.json");
	doSomethingWith(contents);
	console.log("Done");
});
{% endcodeblock %}

### 代理与反射接口
通过调用new Proxy()，你可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。
代理允许你拦截在目标对象上的底层操作，而这原本是JS引擎的内部能力。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。
被Reflect对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。
每个陷阱函数都可以重写JS对象的一个特定内置行为，允许你拦截并修改它。如果你仍然需要使用原先的内置行为，则可使用对应的反射接口方法。

#### 创建一个简单的代理
当你使用Proxy构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（handler），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。

set: 写入一个属性
{% codeblock %}
let target = {
	name: "target"
};
let proxy = new Proxy(target, {
	set(trapTarget, key, value, receiver) {
		// 忽略已有属性，避免影响它们
		if (!trapTarget.hasOwnProperty(key)) {
			if (isNaN(value)) {
				throw new TypeError("Property must be a number.");
			}
		}
		// 添加属性
		return Reflect.set(trapTarget, key, value, receiver);
	}
});
// 添加一个新属性
proxy.count = 1;
console.log(proxy.count); // 1
console.log(target.count); // 1
// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
console.log(target.name); // "proxy"
// 抛出错误
proxy.anotherName = "proxy";
{% endcodeblock %}

get: 读取一个属性的值
{% codeblock %}
let proxy = new Proxy({}, {
	get(trapTarget, key, receiver) {
		if (!(key in receiver)) {
			throw new TypeError("Property " + key + " doesn't exist.");
		}
		return Reflect.get(trapTarget, key, receiver);
	}
});
// 添加属性的功能正常
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
// 读取不存在属性会抛出错误
console.log(proxy.nme); // 抛出错误
{% endcodeblock %}

has: in运算符
{% codeblock %}
let target = {
	name: "target",
	value: 42
};
let proxy = new Proxy(target, {
	has(trapTarget, key) {
		if (key === "value") {
			return false;
		} else {
			return Reflect.has(trapTarget, key);
		}
	}
});
console.log("value" in proxy); // false
console.log("name" in proxy); // true
console.log("toString" in proxy); // true
{% endcodeblock %}

deleteProperty: delete运算符
{% codeblock %}
let target = {
	name: "target",
	value: 42
};
let proxy = new Proxy(target, {
	deleteProperty(trapTarget, key) {
		if (key === "value") {
			return false;
		} else {
			return Reflect.deleteProperty(trapTarget, key);
		}
	}
});
// 尝试删除 proxy.value
console.log("value" in proxy); // true
let result1 = delete proxy.value;
console.log(result1); // false
console.log("value" in proxy); // true
// 尝试删除 proxy.name
console.log("name" in proxy); // true
let result2 = delete proxy.name;
console.log(result2); // true
console.log("name" in proxy); // false
{% endcodeblock %}

getPrototypeOf: Object.getPrototypeOf()
{% codeblock %}
let target = {};
let proxy = new Proxy(target, {
	getPrototypeOf(trapTarget) {
		return null;//返回null隐藏了代理对象的原型，并且使得该原型不可被修改
	},
	setPrototypeOf(trapTarget, proto) {
		return false;
	}
});
let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);
console.log(targetProto === Object.prototype); // true
console.log(proxyProto === Object.prototype); // false
console.log(proxyProto); // null
// 成功
Object.setPrototypeOf(target, {});
// 抛出错误
Object.setPrototypeOf(proxy, {});
{% endcodeblock %}

setPrototypeOf: Object.setPrototypeOf()
{% codeblock %}
let target = {};
let proxy = new Proxy(target, {
	getPrototypeOf(trapTarget) {
		return Reflect.getPrototypeOf(trapTarget);
	},
	setPrototypeOf(trapTarget, proto) {
		return Reflect.setPrototypeOf(trapTarget, proto);
	}
});
let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);
console.log(targetProto === Object.prototype); // true
console.log(proxyProto === Object.prototype); // true
// 成功
Object.setPrototypeOf(target, {});
// 同样成功
Object.setPrototypeOf(proxy, {});
{% endcodeblock %}

isExtensible: Object.isExtensible()
{% codeblock %}
let target = {};
let proxy = new Proxy(target, {
	isExtensible(trapTarget) {
		return Reflect.isExtensible(trapTarget);
	},
	preventExtensions(trapTarget) {
		return Reflect.preventExtensions(trapTarget);
	}
});
console.log(Object.isExtensible(target)); // true
console.log(Object.isExtensible(proxy)); // true
Object.preventExtensions(proxy);
console.log(Object.isExtensible(target)); // false
console.log(Object.isExtensible(proxy)); // false
{% endcodeblock %}

preventExtensions: Object.preventExtensions()
{% codeblock %}
let target = {};
let proxy = new Proxy(target, {
	isExtensible(trapTarget) {
		return Reflect.isExtensible(trapTarget);
	},
	preventExtensions(trapTarget) {
		return false
	}
});
console.log(Object.isExtensible(target)); // true
console.log(Object.isExtensible(proxy)); // true
Object.preventExtensions(proxy);
console.log(Object.isExtensible(target)); // true
console.log(Object.isExtensible(proxy)); // true
{% endcodeblock %}

getOwnPropertyDescriptor: Object.getOwnPropertyDescriptor()
{% codeblock %}
let proxy = new Proxy({}, {
	defineProperty(trapTarget, key, descriptor) {
		return Reflect.defineProperty(trapTarget, key, descriptor);
	},
	getOwnPropertyDescriptor(trapTarget, key) {
		return Reflect.getOwnPropertyDescriptor(trapTarget, key);
	}
});
Object.defineProperty(proxy, "name", {
	value: "proxy"
});
console.log(proxy.name); // "proxy"
let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");
console.log(descriptor.value); // "proxy"
{% endcodeblock %}

defineProperty: Object.defineProperty()
{% codeblock %}
let proxy = new Proxy({}, {
	defineProperty(trapTarget, key, descriptor) {
		if (typeof key === "symbol") {
			return false;     //返回true，Object.defineProperty()会正常执行；返回false，则Object.defineProperty()会抛出错误。
		}
		return Reflect.defineProperty(trapTarget, key, descriptor);
	}
});
Object.defineProperty(proxy, "name", {
	value: "proxy"
});
console.log(proxy.name); // "proxy"
let nameSymbol = Symbol("name");
// 抛出错误
Object.defineProperty(proxy, nameSymbol, {
	value: "proxy"
});
{% endcodeblock %}
你可以让陷阱函数返回true，同时不去调用Reflect.defineProperty()方法，这样Object.defineProperty()就会静默失败，如此便可在未实际去定义属性的情况下抑制运行错误。

ownKeys: Object.keys、Object.getOwnPropertyNames()与Object.getOwnPropertySymbols()
{% codeblock %}
let proxy = new Proxy({}, {
	ownKeys(trapTarget) {
		return Reflect.ownKeys(trapTarget).filter(key => {
			return typeof key !== "string" || key[0] !== "_";
		});
	}
});
let nameSymbol = Symbol("name");
proxy.name = "proxy";
proxy._name = "private";
proxy[nameSymbol] = "symbol";
let names = Object.getOwnPropertyNames(proxy),
keys = Object.keys(proxy);
symbols = Object.getOwnPropertySymbols(proxy);
console.log(names.length); // 1
console.log(names[0]); // "name"
console.log(keys.length); // 1
console.log(keys[0]); // "name"
console.log(symbols.length); // 1
console.log(symbols[0]); // "Symbol(name)"
{% endcodeblock %}

在所有的代理陷阱中，只有apply与construct要求代理目标对象必须是一个函数。

apply: 调用一个函数
{% codeblock %}
let target = function() { return 42 },
proxy = new Proxy(target, {
	apply: function(trapTarget, thisArg, argumentList) {
		return Reflect.apply(trapTarget, thisArg, argumentList);
	},
	construct: function(trapTarget, argumentList) {
		return Reflect.construct(trapTarget, argumentList);
	}
});
// 使用了函数的代理，其目标对象会被视为函数
console.log(typeof proxy); // "function"
console.log(proxy()); // 42
var instance = new proxy();
console.log(instance instanceof proxy); // true
console.log(instance instanceof target); // true
{% endcodeblock %}

construct: 使用new调用一个函数
{% codeblock %}
// 将所有参数相加
function sum(...values) {
	return values.reduce((previous, current) => previous + current, 0);
}
let sumProxy = new Proxy(sum, {
	apply: function(trapTarget, thisArg, argumentList) {
		argumentList.forEach((arg) => {
			if (typeof arg !== "number") {
				throw new TypeError("All arguments must be numbers.");
			}
		});
		return Reflect.apply(trapTarget, thisArg, argumentList);
	},
	construct: function(trapTarget, argumentList) {
		throw new TypeError("This function can't be called with new.");
		//return Reflect.construct(trapTarget, argumentsList);
	}
});
console.log(sumProxy(1, 2, 3, 4)); // 10
// 抛出错误
console.log(sumProxy(1, "2", 3, 4));
// 同样抛出错误
let result = new sumProxy();
{% endcodeblock %}

#### 可被撤销的代理
在被创建之后，代理通常就不能再从目标对象上被解绑。
你可以使用Proxy.revocable()方法来创建一个可被撤销的代理，该方法接受的参数与Proxy构造器的相同：一个目标对象、一个代理处理器，而返回值是包含下列属性的一个对象：
1.  proxy  ：可被撤销的代理对象；
2.  revoke  ：用于撤销代理的函数。
当revoke()函数被调用后，就不能再对该proxy对象进行更多操作，任何与该代理对象交互的意图都会触发代理的陷阱函数，从而抛出一个错误。
{% codeblock %}
let target = {
	name: "target"
};
let { proxy, revoke } = Proxy.revocable(target, {});
console.log(proxy.name); // "target"
revoke();
// 抛出错误
console.log(proxy.name);
{% endcodeblock %}

### 用模块封装代码
模块（Modules）是使用不同方式加载的JS文件（与JS原先的脚本加载方式相对）。
1. 模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；
2. 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；
3. 模块顶级作用域的this值为undefined；
4. 模块不允许在代码中使用HTML风格的注释（这是JS来自于早期浏览器的历史遗留特性）；
5. 对于需要让模块外部代码访问的内容，模块必须导出它们；
6. 允许模块从其他模块导入绑定。

#### 基本的导出
export放置在任意变量、函数或类声明之前，从模块中将它们公开出去
{% codeblock %}
// 导出数据
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;
// 导出函数
export function sum(num1, num2) {
	return num1 + num1;
}
// 导出类
export class Rectangle {
	constructor(length, width) {
		this.length = length;
		this.width = width;
	}
}
// 此函数为模块私有
function subtract(num1, num2) {
	return num1 - num2;
}
// 定义一个函数……
function multiply(num1, num2) {
	return num1 * num2;
}
// ……稍后将其导出
export { multiply };
{% endcodeblock %}
此例中有几点需要注意。首先，除了export关键字之外，每个声明都与正常形式完全一样。每个被导出的函数或类都有名称，这是因为导出的函数声明与类声明必须要有名称。你不能使用这种语法来导出匿名函数或匿名类，除非使用了default关键字（在“模块的默认值”一节会论述）。
其次，细看一下multiply()函数，它并没有在定义时被导出。这是因为你不仅能导出声明，还可以导出引用（即代码最后一行）。
最后请注意，此例并未导出subtract()函数。此函数在模块外部不可访问，因为任意没有被显式导出的变量、函数或类都会在模块内保持私有。

#### 基本的导入
import语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。必须在其中包含文件扩展名。
当从模块导入了一个绑定时，该绑定表现得就像使用了const的定义。这意味着你不能再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的import语句之前使用此标识符（也就是要受暂时性死区限制），更不能修改它的值。

##### 导入单个绑定
{% codeblock %}
//单个导入
import { sum } from "./example.js";
console.log(sum(1, 2)); // 3
sum = 1; //出错
{% endcodeblock %}

##### 导入多个绑定
{% codeblock %}
// 多个导入
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber)); // 8
console.log(multiply(1, 2)); // 2
{% endcodeblock %}

##### 完全导入一个模块
将整个模块当作单一对象进行导入，该模块的所有导出都会作为对象的属性存在。
{% codeblock %}
// 完全导入
import * as example from "./example.js";
console.log(example.sum(1,example.magicNumber)); // 8
console.log(example.multiply(1, 2)); // 2
{% endcodeblock %}

##### 模块语法的限制
1.无论你对同一个模块使用了多少次import语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他import所引用。
2.export与import都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部。只能在模块的顶级作用域使用。

##### 导入绑定的一个微妙怪异点
ES6的import语句为变量、函数与类创建了只读绑定，而不像普通变量那样简单引用了原始绑定。尽管导入绑定的模块无法修改绑定的值，但负责导出的模块却能做到这一点。
{% codeblock %}
export var name = "Nicholas";
export function setName(newName) {
	name = newName;
}
{% endcodeblock %}
当你导入了这两个绑定后，setName()函数还可以改变name的值：
{% codeblock %}
import { name, setName } from "./example.js";
console.log(name); // "Nicholas"
setName("Greg");
console.log(name); // "Greg"
name = "Nicholas"; // error
{% endcodeblock %}
调用setName("Greg")会回到导出setName()的模块内部，并在那里执行，从而将name设置为"Greg"。注意这个变化会自动反映到所导入的name绑定上，这是因为绑定的name是导出的name标识符的本地名称，二者并非同一个事物。外部模块导入的name变量与在example.js模块内部的name变量对比，前者是对于后者的只读引用，会始终反映出后者的变化。就算后者的值在负责导出的模块中发生了变化，这种绑定关系也不会被破坏。模块导出与导入的绑定机制，与写在一个文件或模块内的代码是不同的。

##### 重命名导出与导入
1.假设你想用不同的名称来导出一个函数，你可以使用as关键字来指定新的名称，以便在模块外部用此名称指代目标函数
{% codeblock %}
function sum(num1, num2) {
	return num1 + num2;
}
export { sum as add };
{% endcodeblock %}
2.假若模块导入函数时想使用另一个名称，同样也可以用as关键字：
{% codeblock %}
import { add as sum } from "./example.js";
console.log(typeof add); // "undefined"
console.log(sum(1, 2)); // 3
{% endcodeblock %}

#### 模块的默认值
##### 导出默认值
模块的默认值（default value）是使用default关键字所指定的单个变量、函数或类，而你在每个模块中只能设置一个默认导出，将default关键字用于多个导出会是语法错误。
1.将一个函数作为默认值进行了导出，default关键字标明了这是一个默认导出。此函数并不需要有名称
{% codeblock %}
export default function(num1, num2) {
	return num1 + num2;
}
{% endcodeblock %}
2.export default后面放置一个标识符，以指定默认的导出
{% codeblock %}
function sum(num1, num2) {
	return num1 + num2;
}
export default sum;
{% endcodeblock %}
3.使用重命名语法
{% codeblock %}
function sum(num1, num2) {
	return num1 + num2;
}
export { sum as default };
{% endcodeblock %}
default标识符有特别含义，既作为重命名导出，又标明了模块需要使用的默认值。由于default在JS中是一个关键字，它就不能被用作变量、函数或类的名称（但它可以被用作属性名称）。因此使用default来重命名一个导出是个特例，与非默认导出的语法保持了一致性。若你想用单个语句一次性进行多个导出，并要求包含默认导出，这种语法就非常有用。

##### 导入默认值
1.从一个模块中导入默认值
{% codeblock %}
// 导入默认值
import sum from "./example.js";
console.log(sum(1, 2)); // 3
{% endcodeblock %}
2.对于既导出了默认值、又导出了一个或更多非默认的绑定的模块，你可以使用单个语句来导入它的所有导出绑定。
逗号将默认的本地名称与非默认的名称分隔开，后者仍旧被花括号所包裹。要记住在import语句中默认名称必须位于非默认名称之前。
{% codeblock %}
//example.js
export let color = "red";
export default function(num1, num2) {
	return num1 + num2;
}

//test.js
import sum, { color } from "./example.js";
console.log(sum(1, 2)); // 3
console.log(color); // "red"
{% endcodeblock %}
3.使用重命名语法进行默认值的导入
{% codeblock %}
// 等价于上个例子
import { default as sum, color } from "example";
console.log(sum(1, 2)); // 3
console.log(color); // "red"
{% endcodeblock %}

##### 绑定的再导出
将当前模块已导入的内容重新再导出
{% codeblock %}
export { sum as add } from "./example.js";

//将来自另一个模块的所有值完全导出
export * from "./example.js";
{% endcodeblock %}
使用完全导出，就可以导出目标模块的默认值及其所有具名导出，但这可能影响你从当前模块所能导出的值。例如，假设example.js具有一个默认导出，当你使用这种语法时，你就无法为当前模块另外再定义一个默认导出。

##### 无绑定的导入
有些模块也许没有进行任何导出，相反只是修改全局作用域的对象。尽管这种模块的顶级变量、函数或类最终并不会自动被加入全局作用域，但这并不意味着该模块无法访问全局作用域。诸如Array与Object之类的内置对象的共享定义在模块内部是可访问的，并且对于这些对象的修改会反映到其他模块中。
{% codeblock %}
// 没有导出与导入的模块
Array.prototype.pushAll = function(items) {
	// items 必须是一个数组
	if (!Array.isArray(items)) {
		throw new TypeError("Argument must be an array.");
	}
	// 使用内置的 push() 与扩展运算符
	return this.push(...items);
};
{% endcodeblock %}
这是一个有效的模块，尽管此处没有任何导出与导入。此代码可以作为模块或脚本来使用。由于它没有导出任何东西，你可以使用简化的导入语法来执行此模块的代码，而无须导入任何绑定.
{% codeblock %}
import "./example.js";
let colors = ["red", "green", "blue"];
let items = [];
items.pushAll(colors);
{% endcodeblock %}
此代码导入并执行了包含pushAll()的模块，于是pushAll()就被添加到数组的原型上。这意味着现在pushAll()在当前模块内的所有数组上都可用。

#### 加载模块

##### 在Web浏览器中使用模块
1.在script标签中使用模块
为了支持模块，添加了"module"值作为type的选项。将type设置为"module"，就告诉浏览器要将内联代码或是指定文件中的代码当作模块，而不是当作脚本。
{% codeblock %}
<!-- load a module JavaScript file -->
<script type="module" src="module.js"></script>

<!-- include a module inline -->
<script type="module">
import { sum } from "./example.js";
let result = sum(1, 2);  //并未被暴露到全局，因为它只在使用<script>元素定义的这个模块内部存在，因此也没有被添加为window对象的属性。
</script>
{% endcodeblock %}
你可能已经注意到"module"并不是与"text/javascript"相似的内容类型。模块JS文件的内容类型与脚本JS文件相同，因此不可能依据文件的内容类型将它们完全区别开来。此外，当type属性无法辨认时，浏览器就会忽略<script>元素，因此不支持模块的浏览器也就会自动忽略<script type="module">声明，从而提供良好的向下兼容性。

2.Web浏览器中的模块加载次序
模块相对脚本的独特之处在于：它们能使用import来指定必须要加载的其他文件，以保证正确执行。为了支持此功能，<script type="module">总是表现得像是已经应用了defer属性。
(defer属性规定是否对脚本执行进行延迟，直到页面加载为止。如果您的脚本不会改变文档的内容，可将defer属性加入到<script>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。)
defer属性是加载脚本文件时的可选项，但在加载模块文件时总是自动应用的。当HTML解析到拥有src属性的<script type="module">标签时，就会立即开始下载模块文件，但并不会执行它，直到整个网页文档全部解析完为止。模块也会按照它们在HTML文件中出现的顺序依次执行，这意味着第一个<script type="module">总是保证在第二个之前执行，即使其中有些模块不是用src指定而是包含了内联脚本。
{% codeblock %}
<!-- this will execute first -->
<script type="module" src="module1.js"></script>

<!-- this will execute second -->
<script type="module">
import { sum } from "./example.js";
let result = sum(1, 2);
</script>

<!-- this will execute third -->
<script type="module" src="module2.js"></script>
{% endcodeblock %}
每个import语句又会触发一次fetch（无论是从网络还是从缓存中获取），并且在所有用import导入的资源被加载与执行完毕之前，没有任何模块会被执行。
所有模块，无论是用<script type="module">显式包含的，还是用import隠式包含的，都会依照次序加载与执行。在前面的范例中，完整的加载次序是：
1.下载并解析module1.js；
2.递归下载并解析在module1.js中使用import导入的资源；
3.解析内联模块；
4.递归下载并解析在内联模块中使用import导入的资源；
5.下载并解析module2.js；
6.递归下载并解析在module2.js中使用import导入的资源。
一旦加载完毕，直到页面文档被完整解析之前，都不会有任何代码被执行。在文档解析完毕后，会发生下列行为
1.递归执行module1.js导入的资源；
2.执行module1.js；
3.递归执行内联模块导入的资源；
4.执行内联模块；
5.递归执行module2.js导入的资源；
6.执行module2.js。
注意内联模块除了不必先下载代码之外，与其他两个模块的行为一致，加载import的资源与执行模块的次序都是完全一样的
<script type="module">上的defer属性总是会被忽略，因为它已经应用了该属性。。

3.Web浏览器中的异步模块加载
你或许已熟悉了<script>元素上的async属性。当配合脚本使用时，async会导致脚本文件在下载并解析完毕后就立即执行。但带有async的脚本在文档中的顺序却并不会影响脚本执行的次序，脚本总是会在下载完成后就立即执行，而无须等待包含它的文档解析完毕。
async属性也能同样被应用到模块上。在<script type="module">上使用async会导致模块的执行行为与脚本相似。唯一区别是模块中所有import导入的资源会在模块自身被执行前先下载。这保证了模块中所有需要的资源会在模块执行前被下载，你只是不能保证模块何时会执行。研究以下代码
{% codeblock %}
<!-- no guarantee which one of these will execute first -->
<script type="module" async src="module1.js"></script>
<script type="module" async src="module2.js"></script>
{% endcodeblock %}
此例中两个模块文件被异步加载了。仅查看代码就判断出那个模块会被先执行，这是不可能的。若module1.js首先结束下载（包括它的所有导入资源），那么它就会首先执行。而对于module2.js来说也是一样。

##### 将模块作为Worker加载
为了支持模块加载，HTML标准的开发者为这些worker构造器添加了第二个参数，此参数是一个有type属性的对象，该属性的默认值是"script"。你也可以将type设置为"module"以便加载模块文件：
{% codeblock %}
// 用模块方式加载 module.js
let worker = new Worker("module.js", { type: "module" });
{% endcodeblock %}
worker模块通常与worker脚本一致，但存在两点例外。首先，worker脚本被限制只能从同源的网页进行加载，而worker模块可以不受此限制。尽管worker模块具有相同的默认限制，但当响应头中包含恰当的跨域资源共享（Cross-OriginResourceSharing，CORS）时，就允许跨域加载文件。其次，worker脚本可以使用self.importScripts()方法来将额外脚本引入worker，而worker模块上的self.importScripts()却总会失败，因为应当换用import 。

##### 浏览器模块说明符方案
浏览器要求模块说明符应当为下列格式之一：
1.以/为起始，表示从根目录开始解析；
2.以./为起始，表示从当前目录开始解析；
3.以../为起始，表示从父级目录开始解析；
4.URL 格式。