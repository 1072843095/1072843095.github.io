---
title: 深入理解ES6（1）
date: 2018-03-19 14:46:43
categories: 学习笔记
---

### 块级绑定

#### let, const
1.没有变量提升，且不能在同一个作用域内重复声明一个已有的标识符。
2.const阻止的是对于变量绑定与变量自身值的修改，而不阻止对变量成员的修改。
3.暂时性死区(TDZ代码块)：使用let或const声明的变量，在达到声明处之前都是无法访问的，试图访问会导致一个引用错误，即使在通常是安全的操作时（例如使用typeof运算符），也是如此。

<!-- more -->

#### 循环中的块级绑定
1.let，const在每次迭代中，都会创建一个新的同名变量并对其进行初始化。
2.在循环内部的行为是在规范中特别定义的，而与不提升变量声明的特征没有必然联系。
3.当在全局作用域上使用var时，它会创建一个新的全局变量，并成为全局对象的一个属性。使用let或const不会有任何属性被添加到全局对象上。也就意味着你不能使用let或const来覆盖一个全局变量，你只能将其屏蔽。
{% codeblock %}
// 在浏览器中
var RegExp = "Hello!";
console.log(window.RegExp); // "Hello!"

var ncz = "Hi!";
console.log(window.ncz); // "Hi!"

let RegExp = "Hello!";
console.log(RegExp); // "Hello!"
console.log(window.RegExp === RegExp); // false

const ncz = "Hi!";
console.log(ncz); // "Hi!"
console.log("ncz" in window); // false
{% endcodeblock %}

### 字符串与正则表达式

#### UTF-16 代码点
全球唯一标识符被称为代码点。代码点可以由多个码元组成。codePointAt()与String.fromCodePoint()在代码点和字符之间转换。

#### normalize():比较字符串时，它们必须被标准化为同一种形式
{% codeblock %}
var normalized = values.map(function(text) {
	return text.normalize();
});
normalized.sort(function(first, second) {
	if (first < second) {
		return -1;
	} else if (first === second) {
		return 0;
	} else {
		return 1;
	}
});
{% endcodeblock %}

#### 正则表达式
1.u 标志：正则表达式假定单个字符使用一个 16 位的码元来表示。当一个正则表达式设置了 u 标志时，它的工作模式将切换到针对字符，而不是针对码元。
{% codeblock %}
var text = "" ;
console.log(text.length); // 2
console.log(/^.$/.test(text)); // false
console.log(/^.$/u.test(text)); // true

// 计算代码点数量 (可用，但它并不快，尤其在操作长字符串时。你也可以使用字符串的迭代器来达到相同目的。)
function codePointLength(text) {
	var result = text.match(/[\s\S]/gu);
	return result ? result.length : 0;
}
{% endcodeblock %}
2.y 标志：从正则表达式的lastIndex属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索。
{% codeblock %}
var re = /ab/g;
console.log(re.source); // "ab"
console.log(re.flags); // "g"
{% endcodeblock %}

#### 字符串新增方法
1.includes()：在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；
2.startsWith()：在给定文本出现在字符串起始处时返回 true ，否则返回 false ；
3.endsWith()：在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。
第一个参数只能是字符串，第二个参数是可选的位置
4.repeat()：接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。

#### 模板字面量:在无须连接的情况下，可以创建多行字符串以及将值插入字符串。
{% codeblock %}
let name = "Nicholas",
	message = `Hello, ${
		`my name is ${ name }`
	}.`;
console.log(message);
{% endcodeblock %}

#### 标签化模板
模板标签能对模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个  `  之前。第一个参数是个数组，包含被 JS 解释过的字面量字符串，随后的参数是每个替换位的解释值。
{% codeblock %}
function passthru(literals, ...substitutions) {
	let result = "";
	// 仅使用 substitution 的元素数量来进行循环
	for (let i = 0; i < substitutions.length; i++) {
		result += literals[i];
		result += substitutions[i];
	}
	// 添加最后一个字面量
	result += literals[literals.length - 1];
	return result;
}
let count = 10,
price = 0.25,
message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;
console.log(message); // "10 items cost $2.50."
{% endcodeblock %}

### 函数
#### ES6 中的参数默认值
1.只有在未传递参数、或明确将参数值指定为undefined时,参数默认值才会被使用，null值被认为是有效的。
2.参数默认值并不要求一定是基本类型的值,function add(first, second = getValue()){}。
3.参数默认值的存在触发了arguments对象与具名参数的分离。
{% codeblock %}
function mixArgs(first, second = "b") {
	console.log(arguments.length);
	console.log(first === arguments[0]);
	console.log(second === arguments[1]);
	first = "c";
	second = "d"
	console.log(first === arguments[0]);
	console.log(second === arguments[1]);
}
//1
//true
//false
//false
//false
{% endcodeblock %}
4.参数默认值的函数的arguments反映初始调用状态。arguments对象在函数被调用时反映了传入的参数.
5.参数默认值的暂时性死区，参数初始化会在函数被调用时进行。（函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离）。

#### 剩余参数
1.函数的length属性用于指示具名参数的数量，而剩余参数对其毫无影响。
2.函数只能有一个剩余参数，并且它必须被放在最后。
3.剩余参数不能在对象字面量的setter属性中使用。对象字面量的setter被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，因此它在此处不被许可。
4.arguments  对象总能正确反映被传入函数的参数，而无视剩余参数的使用。
{% codeblock %}
let object = {
	// 语法错误：不能在 setter 中使用剩余参数
	set name(...value) {
		// 一些操作
	}
};
{% endcodeblock %}

#### 函数的双重用途
1.JS 为函数提供了两个不同的内部方法[[Call]]与[[Construct]]。当函数未使用new进行调用时，[[call]]方法会被执行，运行的是代码中显示的函数体。而当函数使用new进行调用时，[[Construct]]方法则会被执行，负责创建一个被称为新目标的新的对象，并且使用该新目标作为this去执行函数体。拥有[[Construct]]方法的函数被称为构造器。
2.记住并不是所有函数都拥有[[Construct]]方法，因此不是所有函数都可以用new来调用。在“箭头函数”小节中介绍的箭头函数就未拥有该方法。

#### new.target元属性
1.元属性指的是‘非对象’上的一个属性，并提供关联到它的目标的附加信息。
2.当函数的[[Construct]]方法被调用时，new.target会被填入new运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的this值。而若[[Call]]被执行，new.target的值则会是undefined  。
3.通过检查  new.target  是否被定义，这个新的元属性就让你能安全地判断函数是否被使用new进行了调用。
{% codeblock %}
function Person(name) {
	if (typeof new.target !== "undefined") {
		this.name = name; // 使用 new
	} else {
		throw new Error("You must use new with Person.")
	}
}
var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael"); // 出错！
{% endcodeblock %}
4.也可以检查new.target是否被使用特定构造器进行了调用.
{% codeblock %}
function Person(name) {
	if (new.target === Person) {
		this.name = name; // 使用 new
	} else {
		throw new Error("You must use new with Person.")
	}
}
function AnotherPerson(name) {
	Person.call(this, name);  //new.target值为undefined（Person并未使用new调用）
}
var person = new Person("Nicholas");
var anotherPerson = new AnotherPerson("Nicholas"); // 出错！
{% endcodeblock %}

#### 块级函数
1.ES6中块级函数会被视为块级声明，严格模式下提升到定义所在的代码块的顶部（非严格模式下会被提升到所在函数或全局环境的顶部），并允许它在定义所在的代码块内部被访问。
2.块级函数在执行流跳出定义所在的代码块之后，函数定义就会被移除。


#### 箭头函数
1.没有this、super，arguments，也没有new.target绑定：this、super、arguments、以及函数内部的new.target的值由所在的、最靠近的非箭头函数来决定。
2.不能被使用new调用： 箭头函数没有[[Construct]]方法，因此不能被用为构造函数，使用new调用箭头函数会抛出错误。
3.没有原型： 既然不能对箭头函数使用new，那么它也不需要原型，也就是没有prototype属性。
4.不能更改this：this的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。
{% codeblock %}
var a = ()=>{
    this='1';
    console.log(this);
};
//Uncaught ReferenceError: Invalid left-hand side in assignment
{% endcodeblock %}
5.没有arguments对象： 既然箭头函数没有arguments绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。
6.不允许重复的具名参数：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。
7.箭头函数也拥有name属性，并且遵循与其他函数相同的规则。
8.使用传统函数时，(function(){/*函数体*/})();与(function(){/*函数体*/}());这两种方式都是可行的。但若使用箭头函数，则只有下面的写法是有效的：(() => {/*函数体*/})();


### 扩展的对象功能

#### 对象字面量
1.当对象的一个属性名称与本地变量名相同时，你可以简单书写名称而省略冒号与值。
2.方法简写语法:省略冒号与function关键字。方法简写能使用super，而非简写的方法则不能。
{% codeblock %}
function createPerson(name, age) {
	return {
		name,
		age,
		sayName() {
			console.log(this.name);
		}
	};
}
{% endcodeblock %}
3.需计算属性名
对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串。这意味着其中可以包含表达式。
{% codeblock %}
var lastName = "last name";
var person = {
	"first name": "Nicholas",
	[lastName]: "Zakas"
};
console.log(person["first name"]); // "Nicholas"
console.log(person[lastName]); // "Zakas"

var suffix = " name";
var person = {
	["first" + suffix]: "Nicholas",
	["last" + suffix]: "Zakas"
};
console.log(person["first name"]); // "Nicholas"
console.log(person["last name"]); // "Zakas"
{% endcodeblock %}
4.Object.is()：此方法接受两个参数，并会在二者的值相等时返回true，此时要求二者类型相同并且值也相等。在许多情况下，Object.is()的结果与===运算符是相同的，仅有的例外是：它会认为+0与-0不相等，而且NaN等于NaN。
{% codeblock %}
console.log(+0 == -0); // true
console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false

console.log(NaN == NaN); // false
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true

console.log(5 == 5); // true
console.log(5 == "5"); // true
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(Object.is(5, 5)); // true
console.log(Object.is(5, "5")); // false
{% endcodeblock %}
5.Object.assign() :方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的。
{% codeblock %}
var receiver = {};
Object.assign(receiver,
	{
		type: "js",
		name: "file.js"
	},
	{
		type: "css"
	}
);
console.log(receiver.type); // "css"
console.log(receiver.name); // "file.js"
{% endcodeblock %}
需要记住Object.assign()并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于Object.assign()使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性。
{% codeblock %}
var receiver = {},
supplier = {
	get name() {
		return "file.js"
	}
};
Object.assign(receiver, supplier);
var descriptor = Object.getOwnPropertyDescriptor(receiver, "name");
console.log(descriptor.value); // "file.js"
console.log(descriptor.get); // undefined
/*
此代码中的supplier对象拥有一个名为name的访问器属性。在使用了Object.assign()方法后，receiver.name就作为一个数据属性存在了，其值为"file.js"，这是因为在调用Object.assign()时，supplier.name返回的值是"file.js"。
*/
{% endcodeblock %}

#### 更强大的原型
1.Object.setPrototypeOf()：此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。
{% codeblock %}
let person = {
	getGreeting() {
		return "Hello";
	}
};
let dog = {
	getGreeting() {
		return "Woof";
	}
};
// 原型为 person
let friend = Object.create(person);
console.log(friend.getGreeting()); // "Hello"
console.log(Object.getPrototypeOf(friend) === person); // true

// 将原型设置为 dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting()); // "Woof"
console.log(Object.getPrototypeOf(friend) === dog); // true
{% endcodeblock %}
2.super是指向当前对象的原型的一个指针，实际上就是Object.getPrototypeOf(this)的值。你能使用super引用来调用对象原型上的任何方法，只要这个引用是位于简写的方法之内。试图在方法简写之外的情况使用super会导致语法错误。super引用并非是动态的，它总是能指向正确的对象。
{% codeblock %}
let friend = {
	getGreeting() {
		// 这相当于上个例子中的：
		// Object.getPrototypeOf(this).getGreeting.call(this)  多级继承不行
		return super.getGreeting() + ", hi!";
	}
};
{% endcodeblock %}
3.方法是一个拥有[[HomeObject]]内部属性的函数，此内部属性指向该方法所属的对象。任何对super的引用都会使用[[HomeObject]]属性来判断要做什么。第一步是在[[HomeObject]]上调用Object.getPrototypeOf()来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建this绑定并调用该方法。
{% codeblock %}
let person = {
	// 方法
	getGreeting() {
		return "Hello";
	}
};

// 并非方法
function shareGreeting() {
	return "Hi!";
}
{% endcodeblock %}

### 解构
当解构赋值表达式的右侧（=后面的表达式）的计算结果为null或undefined时，会抛出错误。因为任何读取null或undefined的企图都会导致“运行时”错误（runtime error）。

#### 对象解构
1.当使用解构来配合var、let或const来声明变量时，必须提供初始化器（即等号右边的值）。当解构赋值表达式的右侧（=  后面的表达式）的计算结果为null或undefined时，会抛出错误。因为任何读取null或undefined的企图都会导致“运行时”错误（runtime error ）。
{% codeblock %}
// 语法错误！
var { type, name };

// 语法错误！
let { type, name };

// 语法错误！
const { type, name };
/*
const  总是要求有初始化器，即使没有使用解构的变量；而var与let则仅在使用解构时才作此要求。
*/
{% endcodeblock %}
2.注意你必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。
{% codeblock %}
let node = {
	type: "Identifier",
	name: "foo"
},
type = "Literal",
name = 5;
// 使用解构来分配不同的值
({ type, name } = node);
console.log(type); // "Identifier"
console.log(name); // "foo"
{% endcodeblock %}
3.解构赋值表达式的值为表达式右侧（在=之后）的值。也就是说在任何期望有个值的位置都可以使用解构赋值表达式。
{% codeblock %}
let node = {
	type: "Identifier",
	name: "foo"
},
type = "Literal",
name = 5;
function outputInfo(value) {
	console.log(value === node); // true
}
outputInfo({ type, name } = node);
console.log(type); // "Identifier"
console.log(name); // "foo"
{% endcodeblock %}
4.当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为undefined。你可以选择性地定义一个默认值，以便在指定属性不存在或值为undefined时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值.
5.赋值给不同的本地变量名、给变量别名添加默认值
{% codeblock %}
let node = {
	type: "Identifier"
};
let { type: localType, name: localName = "bar" } = node;
console.log(localType); // "Identifier"
console.log(localName); // "bar"
{% endcodeblock %}
6.嵌套的对象解构:每当有一个冒号在解构模式中出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中。
{% codeblock %}
let node = {
	type: "Identifier",
	name: "foo",
	loc: {
		start: {
			line: 1,
			column: 1
		},
		end: {
			line: 1,
			column: 4
		}
	}
};
// 提取 node.loc.start
let { loc: { start: localStart }} = node;
console.log(localStart.line); // 1
console.log(localStart.column); // 1
{% endcodeblock %}

#### 数组解构
1.与对象解构相似，在使用var、let、const进行数组解构时，你必须提供初始化器。
2.你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内。
3.能轻易地互换两个变量的值。与对象解构赋值相同，若等号右侧的计算结果为null或undefined，那么数组解构赋值表达式也会抛出错误。
{% codeblock %}
// 在 ES6 中互换值
let a = 1,
b = 2;
[ a, b ] = [ b, a ];
console.log(a); // 2
console.log(b); // 1
/*
赋值语句左侧（即等号之前）的解构模式正如其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。b与a的值分别被复制到临时数组的第一个与第二个位置，并对该数组进行解构，结果两个变量就互换了它们的值。
*/
{% endcodeblock %}
4.数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为undefined，那么该默认值就会被使用。
{% codeblock %}
let colors = [ "red" ];
let [ firstColor, secondColor = "green" ] = colors;
console.log(firstColor); // "red"
console.log(secondColor); // "green"
{% endcodeblock %}
5.剩余项:使用...语法来将剩余的项目赋值给一个指定的变量。剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。
{% codeblock %}
let colors = [ "red", "green", "blue" ];
let [ firstColor, ...restColors ] = colors;
console.log(firstColor); // "red"
console.log(restColors.length); // 2
console.log(restColors[0]); // "green"
console.log(restColors[1]); // "blue"

//ES5中： concat()  方法的本意是合并两个数组，但不使用任何参数来调用此方法，就会获得原数组的一个克隆品。
// 在 ES6 中克隆数组
let colors = [ "red", "green", "blue" ];
let [ ...clonedColors ] = colors;
console.log(clonedColors); //"[red,green,blue]"
{% endcodeblock %}
6.函数的参数解构有一个怪异点：默认情况下调用函数时未给参数解构传值会抛出错误。可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。
{% codeblock %}
function setCookie(name, value,
	{
		secure = false,
		path = "/",
		domain = "example.com",
		expires = new Date(Date.now() + 360000000)
		} = {}
) {
// ...
}
/*
此代码中参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。而整个解构的参数同样有一个默认值，即一个空对象，令该参数成为可选参数。这么做使得函数声明看起来比平时要复杂一些，但却是为了确保每个参数都有可用的值而付出的微小代价。
*/
{% endcodeblock %}

### 符号与符号属性
#### 创建符号值
1.使用全局Symbol函数来创建一个符号值:Symbol()。由于符号值是基本类型的值，因此调用new Symbol()将会抛出错误。使用typeof返回"symbol"。
2.Symbol函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试。符号的描述信息被存储在内部属性[[Description]]中，当符号的toString()方法被显式或隐式调用时，该属性都会被读取。此外没有任何办法可以从代码中直接访问[[Description]]属性。
{% codeblock %}
let firstName = Symbol("first name");
let person = {};
person[firstName] = "Nicholas";
console.log("first name" in person); // false
console.log(person[firstName]); // "Nicholas"
console.log(firstName); // "Symbol(first name)"
{% endcodeblock %}
3.使用符号值：无法用for-in循环遍历，也不会显示在Object.keys()的结果中。
{% codeblock %}
let firstName = Symbol("first name");
// 使用一个需计算字面量属性
let person = {
	[firstName]: "Nicholas"
};
// 让该属性变为只读
Object.defineProperty(person, firstName, { writable: false });
let lastName = Symbol("last name");
Object.defineProperties(person, {
	[lastName]: {
		value: "Zakas",
		writable: false
	}
});
console.log(person[firstName]); // "Nicholas"
console.log(person[lastName]); // "Zakas
{% endcodeblock %}
4.ES6 提供了“全局符号注册表”供你在任意时间点访问符号值。全局符号注册表类似于全局作用域，是一个共享环境。若你想创建共享符号值，应使用Symbol.for()方法而不是Symbol()方法。Symbol.for()方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。Symbol.for()  方法首先会搜索全局符号注册表，看是否存在一个键值为"uid"的符号值。若是，该方法会返回这个已存在的符号值；否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值。这就意味着此后使用同一个键值去调用Symbol.for()方法都将会返回同一个符号值。
{% codeblock %}
let uid = Symbol.for("uid");
let object = {
	[uid]: "12345"
};
console.log(object[uid]); // "12345"
console.log(uid); // "Symbol(uid)"

let uid2 = Symbol.for("uid");
console.log(uid === uid2); // true
console.log(object[uid2]); // "12345"
console.log(uid2); // "Symbol(uid)"
{% endcodeblock %}
你可以使用Symbol.keyFor()方法在全局符号注册表中根据符号值检索出对应的键值。
{% codeblock %}
let uid = Symbol.for("uid");
console.log(Symbol.keyFor(uid)); // "uid"
let uid2 = Symbol.for("uid");
console.log(Symbol.keyFor(uid2)); // "uid"
let uid3 = Symbol("uid");
console.log(Symbol.keyFor(uid3)); // undefined
/*
使用符号值uid与uid2都返回了键值"uid"，而符号值uid3在全局符号注册表中并不存在，因此没有关联的键值，Symbol.keyFor()方法只会返回undefined。
*/
{% endcodeblock %}
5.String()或.toString()来获取符号的字符串描述信息。接将符号转换为字符串或数值，则会引发错误。
{% codeblock %}
let uid = Symbol.for("uid"),
desc = String(uid);
console.log(desc); // "Symbol(uid)"

let uid = Symbol.for("uid"),
desc = uid + ""; // 引发错误！

let uid = Symbol.for("uid"),
sum = uid / 1; // 引发错误！
{% endcodeblock %}

#### 检索符号属性
1.Object.keys()与Object.getOwnPropertyNames()方法可以检索对象的所有属性名称，前者返回所有的可枚举属性名称，而后者则返回所有属性名称而无视其是否可枚举。然而两者都不能返回符号类型的属性。
2.Object.getOwnPropertySymbols()方法，可以检索对象的符号类型属性。会返回一个数组，包含了对象自有属性名中的符号值。

#### 知名符号
所有对象初始情况下都不包含任何自有符号类型属性，但对象可以从它们的原型上继承符号类型属性。ES6预定义了一些此类属性，它们被称为“知名符号”。

##### 使用知名符号暴露内部方法
略