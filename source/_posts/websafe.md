---
title: 浏览器安全
date: 2018-02-05 16:15:51
categories: 学习笔记
---

浏览器安全

### HTTP首部
#### X-Content-Type-Options
   浏览器可以使用各种检测技术判断服务器返回了什么类型的内容。然后，浏览器会执行一些与该内容类型相关的操作。而 nosniff 指令可以禁用浏览器的上述行为，强制浏览器按照Content-type首部来渲染内容。
<!-- more -->
   举个例子，如果服务器给一个 script 标签返回的响应中带有 nosniff 指令，那么除非响应的MIME类型是 application/javascript （或其他几个字符串），否则浏览器会忽略响应内容。对Wikipedia之类（允许上传）的网站来说，能做到这一点非常重要。
假如响应不包含这个指令，而且有人上传了一个特殊的文件，后来该文件又被人下载的话，可能就会造成威胁。此时，浏览器可能就会按照惯例错误地解释文件的MIME类型，例如把JPEG当作脚本来解释。从浏览器安全角度来看，很可能有人会利用这一点控制浏览器。比如，这个人上传一种允许上传的文件（看起来似乎很安全），而浏览器随后却以另一种比较危险和易变的方式去解释它。


#### Strict-Transport-Security
这个HTTP首部指示浏览器必须通过有效的HTTPS通道与网站通信。如果是一个不安全的连接，用户不可能接受HTTPS错误并继续浏览网站。相反，浏览器会解释错误，并且不允许用户继续浏览。

#### X-Frame-Options
X-Frame-Options HTTP首部用于阻止浏览器中的页面内嵌框架。浏览器在看到这个首部后，应该保证不把接收到的页面显示在一个IFrame中。
	制定这个首部的目的是防止发生界面伪装（UI redressing）攻击，其中之一就是点击劫持（clickjacking）。这种攻击是把诱导页面放到一个完全透明的前景框架窗口中，而用户以为自己点
击的是下方不透明的（被攻击的）页面，实际上点击的却是透明的前景（诱导）页面。

### 初始控制

#### 使用XSS攻击
反射型XSS和持久型XSS是利用服务器端隐患。DOM XSS和通用XSS是利用客户端缺陷。

##### 反射型XSS
不可信用户数据被提交到一个web应用，然后该数据立即在响应中被返回，也就是说在页面中反射了不可信内容。由于浏览器看到的是服务器端代码，所以就相信它是安全的，于是就会执行它。
例子：当遇到"http://browservictim.com/userhome.jsp?user= <iframe%20src=http://browserhacker.com/></iframe>"时，如果直接把user值展示在页面中，就会在页面中插入一个地址为browserhacker.com的框架。iframe换成script可以注入远端脚本。
尝试：1.js获取url的查询字符串decodeURIComponent后再innerHTML插入页面，插入script，并没有加载。2.新建一个div(或script)标签，innerHTML设为前面decodeURIComponent后的值，插入成功(script报错)，没有载入。（创建script标签，src引入不考虑）
结论：服务器渲染的隐患。纯前端页面不存在这个问题。
模糊url的方法：1.缩短url 2.重定向url 3.采用url编码或ASCII编码来编码url 4.添加一些多余的、无关的查询参数，把恶意内容放在中间或后面 5.在url中使用@符号以添加伪域名内容 6.把主机名转换为整数，比如http://4362362363777

##### 存储型XSS
存储型（或持久型）XSS与反射型XSS类似，区别在于存储型XSS会持久保存于Web应用的数据存储中。随后，只要是在脚本被持久存储后访问被侵入网站的浏览器，都会执行该恶意代码。
例子：在上一节中反射型XSS示例的基础上，假设应用也要把用户的显示名称保存起来。假设在应用中的某个地方，有代码会提取最后登录用户的列表。

##### DOM XSS
使用document.write、document.writeln、eval等造成的

##### 通用型XSS
通用型XSS是另一种在浏览器中执行恶意JavaScript的方法。利用浏览器本身的缺陷、扩展或插件的缺陷。

### 攻击Web应用

#### CSRF 攻击利用了Web应用对其用户的HTTP请求的信任。
攻击者可以伪造跨域AJAX请求。浏览器处理该请求后，请求会自动包含用户的cookie，因而就变成了合法认证过的请求了。使用JavaScript动态创建和提交参数相同的HTML表单，也可以
伪造同样的请求。这些请求通常会被Web应用信任，是因为用户已经登录过了，而且每次请求都会有相应的cookie随之发送给源。之所以可以利用这种漏洞，是因为HTTP请求可以被模仿，而
HTTP协议也未说明如何处理独一无二的请求。
防御：如果在浏览器发送给Web应用的请求后面，加上一个伪随机token（防御XSRF的token）作为参数，那么XSRF攻击可能会失败 。

##### 通过XSS绕过防御XSRF的token
防御XSRF的token的作用是降低跨站点请求伪造攻击成功的可能性，但对XSS无效。如果目
标Web应用使用了防御XSRF的token，而你通过勾连控制了目标源，则可以绕过该保护机制。
