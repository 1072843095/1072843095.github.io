---
title: 深入理解ES6（2）
date: 2018-03-21 15:45:19
categories: 学习笔记
---

### Set与Map
对象属性的类型必须为字符串,非字符串值会在内部被转换为字符串。属性为对象时被转换为"[object Object]" 。
JS存在in运算符，若属性存在于对象中，就会返回true而无须读取对象的属性值。不过，in运算符会搜索对象的原型，这使得它只有在处理原型为null的对象时才是安全的。
<!-- more -->
#### set
这是一种无重复值的有序列表。Set允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式。
1.Set使用new Set()来创建，而调用add()方法就能向Set中添加项目，检查size属性还能查看其中包含有多少项。你还可以向Set添加多个对象，它们不会被合并为同一项。
2.在 Set 内部的比较使用了Object.is()方法，来判断两个值是否相等，唯一的例外是+0与-0在Set中被判断为是相等的。
3.如果add()方法用相同值进行了多次调用，那么在第一次之后的调用实际上会被忽略。你可以使用数组来初始化一个Set，并且Set构造器会确保不重复地使用这些值。
4.Set构造器实际上可以接收任意可迭代对象作为参数。能使用数组是因为它们默认就是可迭代的，Set与Map也是一样。Set构造器会使用迭代器来提取参数中的值。
{% codeblock %}
let set = new Set();
set.add(5);
set.add("5");
set.add(5); // 重复了，该调用被忽略
console.log(set.size); // 2

let set = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
console.log(set.size); // 5
{% endcodeblock %}
5.使用has()方法来测试某个值是否存在于Set中，使用delete()方法来移除单个值，或调用clear()方法来将所有值从Set中移除。
{% codeblock %}
let set = new Set();
set.add(5);
set.add("5");
console.log(set.has(5)); // true
set.delete(5);
console.log(set.has(5)); // false
console.log(set.size); // 1
set.clear();
console.log(set.has("5")); // false
console.log(set.size); // 0
{% endcodeblock %}
6.forEach()方法会被传递一个回调函数，该回调接受三个参数：1. Set 中下个位置的值；2. 与第一个参数相同的值；3. 目标 Set 自身。如果想在回调函数中使用this，你可以给forEach()传入一个this值作为第二个参数。也可以使用箭头函数来达到相同效果，而无须传入第二个参数。
{% codeblock %}
let set = new Set([1, 2]);
let processor = {
	output(value) {
		console.log(value);
	},
	process(dataSet) {
		dataSet.forEach(function(value) {
			this.output(value);
		}, this);
	}
};
processor.process(set);

//使用箭头函数
let set = new Set([1, 2]);
let processor = {
	output(value) {
		console.log(value);
	},
	process(dataSet) {
		dataSet.forEach((value) => this.output(value));
	}
};
processor.process(set);
{% endcodeblock %}
7.将数组转换为Set相当容易，因为可以将数组传递给Set构造器；而使用扩展运算符也能简单地将Set转换回数组。
{% codeblock %}
let set = new Set([1, 2, 3, 3, 3, 4, 5]),
array = [...set];
console.log(array); // [1,2,3,4,5]
{% endcodeblock %}

#### WeakSet
1.该类型只允许存储对象弱引用，而不能存储基本类型的值。
2.包含add()方法、has()方法以及delete()方法。
3.对于WeakSet的实例，若调用add()方法时传入了非对象的参数，就会抛出错误（has()或delete()则会在传入了非对象的参数时返回false）；
4.Weak Set 不可迭代，因此不能被用在for-of循环中；
5.Weak Set 无法暴露出任何迭代器（例如keys()与values()方法），因此没有任何编程手段可用于判断Weak Set的内容；
6.Weak Set 没有forEach()方法；
7.Weak Set 没有size属性。
8.clear()方法不存在

#### Map
ES6的Map类型是键值对的有序列表，而键和值都可以是任意类型。
1.调用set()方法并给它传递一个键与一个关联的值，来给Map添加项；此后使用键名来调用get()方法便能提取对应的值。如果任意一个键不存在于 Map 中，则get()方法就会返回特殊值undefined。
{% codeblock %}
let map = new Map();
map.set("title", "Understanding ES6");
map.set("year", 2016);
console.log(map.get("title")); // "Understanding ES6"
console.log(map.get("year")); // 2016
{% endcodeblock %}
2.has(key),delete(key),clear(),拥有size属性，用于指明包含了多少个键值对。
3.初始化：你能将数组传递给Map构造器，以便使用数据来初始化一个 Map。该数组中的每一项也必须是数组，内部数组的首个项会作为键，第二项则为对应值。因此整个Map 就被这些双项数组所填充。
{% codeblock %}
let map = new Map([["name", "Nicholas"], ["age", 25]]);
console.log(map.has("name")); // true
console.log(map.get("name")); // "Nicholas"
console.log(map.has("age")); // true
console.log(map.get("age")); // 25
console.log(map.size); // 2
{% endcodeblock %}
4.forEach()它接受一个能接收三个参数的回调函数：1. Map 中下个位置的值；2. 该值所对应的键；3. 目标 Map 自身。
5.你也可以给forEach()提供第二个参数来指定回调函数中的this值，其行为与Set版本的forEach()一致。

#### WeakMap
在 Weak Map 中，所有的键都必须是对象（尝试使用非对象的键会抛出错误），而且这些对象都是弱引用，不会干扰垃圾回收。当 Weak Map中的键在 Weak Map之外不存在引用时，该键值对会被移除。
1.Weak Map的最佳用武之地，就是在浏览器中创建一个关联到特定DOM元素的对象。
2.必须注意的是，Weak Map的键才是弱引用，而值不是。在Weak Map的值中存储对象会阻止垃圾回收，即使该对象的其他引用已全都被移除。
3.ES6的WeakMap类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。
4.set(),get(),has(),delete(),
5.没有size属性,clear()方法不存在,不能使用forEach()方法
6.Weak Map 的一个实际应用就是在对象实例中存储私有数据。
{% codeblock %}
let Person = (function() {
	let privateData = new WeakMap();
	function Person(name) {
		privateData.set(this, { name: name });
	}
	Person.prototype.getName = function() {
		return privateData.get(this).name;
	};
	return Person;
}());
{% endcodeblock %}


### 迭代器与生成器
#### 迭代器
迭代器是被设计专用于迭代的对象，带有特定接口。所有的迭代器对象都拥有next()方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的value，以及一个布尔类型的done，其值为true时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了next()方法，迭代器就会返回相应的下一个值。
若你在最后一个值返回后再调用next()，所返回的done属性值会是true，并且value属性值会是迭代器自身的返回值（return value，即使用return语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用undefined。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。
{% codeblock %}
//在 ES5 中创建一个迭代器
function createIterator(items) {
	var i = 0;
	return {
		next: function() {
			var done = (i >= items.length);
			var value = !done ? items[i++] : undefined;
			return {
				done: done,
				value: value
			};
		}
	};
}
var iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: 3, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
// 之后的所有调用
console.log(iterator.next()); // "{ value: undefined, done: true }"
{% endcodeblock %}
幸好， ES6 还提供了生成器，让创建迭代器对象变得更简单。

#### 生成器
生成器（generator）是能返回一个迭代器的函数。生成器函数由放在function关键字之后的一个星号（*）来表示，并能使用新的yield关键字。将星号紧跟在function关键字之后，或是在中间留出空格，都是没问题的。yield关键字也是ES6新增的，指定了迭代器在被next()方法调用时应当按顺序返回的值。yield  关键字可以和值或是表达式一起使用。
{% codeblock %}
// 生成器
function *createIterator() {
	yield 1;
	yield 2;
	yield 3;
}
// 生成器能像正规函数那样被调用，但会返回一个迭代器
let iterator = createIterator();
console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
{% endcodeblock %}
1.生成器函数最有意思的方面可能就是它们会在每个yield语句后停止执行。例如，此代码中yield 1执行后，该函数将不会再执行任何操作，直到迭代器的next()方法被调用，此时才继续执行yield 2。
2.yield关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部的函数中也不行
{% codeblock %}
function *createIterator(items) {
	items.forEach(function(item) {
		// 语法错误
		yield item + 1;
	});
}
/*
尽管yield严格位于createIterator()内部，此代码仍然有语法错误，因为yield无法穿越函数边界。从这点上来说，yield与return非常相似，在一个被嵌套的函数中无法将值返回给包含它的函数。
*/
{% endcodeblock %}
3.你可以使用函数表达式来创建一个生成器，只要在function关键字与圆括号之间使用一个星号（*）即可。不能将箭头函数创建为生成器。
4.由于生成器就是函数，因此也可以被添加到对象中。例如，你可以在ES5风格的对象字面量中使用函数表达式来创建一个生成器。你也可以使用ES6方法的速记法，只要在方法名之前加上一个星号（*）。

#### 可迭代对象与 for-of 循环
可迭代对象（iterable）是包含Symbol.iterator属性的对象。这个Symbol.iterator知名符号定义了为指定对象返回迭代器的函数。在ES6中，所有的集合对象（数组、Set与Map）以及字符串都是可迭代对象，因此它们都被指定了默认的迭代器。可迭代对象被设计用于与ES新增的for-of循环配合使用。
1.生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为Symbol.iterator属性赋值。
2.for-of循环首先在JS引擎后台Symbol.iterator方法，获取了一个迭代器，在循环每次执行时会调用可迭代对象的next()方法，并将结果对象的value值存储在一个变量上。循环过程会持续到结果对象的done属性变成true为止。
3.在不可迭代对象、null或undefined上使用for-of语句，会抛出错误。
4.开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的Symbol.iterator属性，让它们成为可迭代对象。
{% codeblock %}
let collection = {
	items: [],
	*[Symbol.iterator]() {    //注意名称之前依然有星号
		for (let item of this.items) {
			yield item;
		}
	}
};
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);
for (let x of collection) {
	console.log(x);
}
输出：
1
2
3
{% endcodeblock %}


#### 内置的迭代器
1.数组、Map与Set :
(1)entries()返回一个包含键值对的迭代器；
会在每次next()被调用时返回一个双项数组，此数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引；对于Set，第一项也是值（因为它的值也会被视为键）；对于Map，第一项就就是键。
(2)values()返回一个包含集合中的值的迭代器；
(3)keys()返回一个包含集合中的键的迭代器。
能返回集合中的每一个键。对于数组来说，它只返回了数值类型的键，永不返回数组的其他自有属性；Set的键与值是相同的，因此它的keys()与values()返回了相同的迭代器；对于Map，keys()迭代器返回了每个不重复的键。
for-in循环会迭代所有属性而不仅是数值索引。
(4)当for-of循环没有显式指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。values()方法是数组与Set的默认迭代器，而entries()方法则是Map的默认迭代器。
(5)Weak Set与Weak Map并未拥有内置的迭代器，使用弱引用意味着无法获知这些集合内部到底有多少个值，同时意味着没有方法可以迭代这些值。
(6)Map 默认迭代器的行为有助于在for-of循环中使用解构
{% codeblock %}
let data = new Map();
data.set("title", "Understanding ES6");
data.set("format", "ebook");
// 与使用 data.entries() 相同
for (let [key, value] of data) {
	console.log(key + "=" + value);
}
//此代码中的for-of循环使用了数组解构，来将Map中的每个项存入key与value变量。
{% endcodeblock %}
2.字符串的迭代器：字符串默认迭代器配合for-of循环，能处理字符而不是码元，会得到更加合适的输出。
3.NodeList 的迭代器： for-of循环迭代
4.扩展运算符与非数组的可迭代对象：扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。

#### 迭代器高级功能
1.传递参数给迭代器
当一个参数被传递给next()方法时，该参数就会成为生成器内部yield语句的值。这种能力对于更多高级功能（例如异步编程）来说是非常重要的。
{% codeblock %}
function *createIterator() {
	let first = yield 1;
	let second = yield first + 2; // 4 + 2
	yield second + 3; // 5 + 3
}
let iterator = createIterator();
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next(4)); // "{ value: 6, done: false }"
console.log(iterator.next(5)); // "{ value: 8, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
{% endcodeblock %}
{% img "/uploads/yield.png" "在一个生成器内部的代码执行" %}
对于next()的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给next()的参数会成为yield语句的值，该yield语句指的是上次生成器中断执行处的语句；而next()方法第一次被调用时，生成器函数才刚刚开始执行，没有所谓的“上一次中断处的yield语句”可供赋值。因此在第一次调用next()时，不存在任何向其传递参数的理由。
2.在迭代器中抛出错误
能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个throw()方法，用于指示迭代器应在恢复执行时抛出一个错误。
{% codeblock %}
function *createIterator() {
	let first = yield 1;
	let second = yield first + 2; // yield 4 + 2 ，然后抛出错误
	yield second + 3; // 永不会被执行
}
let iterator = createIterator();
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next(4)); // "{ value: 6, done: false }"
console.log(iterator.throw(new Error("Boom"))); // 从生成器中抛出了错误
{% endcodeblock %}
{% img "/uploads/error.png" "在一个生成器内部抛出错误" %}
可以在生成器内部使用一个try-catch块来捕捉这种错误。
{% codeblock %}
function *createIterator() {
	let first = yield 1;
	let second;
	try {
		second = yield first + 2; // yield 4 + 2 ，然后抛出错误
	} catch (ex) {
		second = 6; // 当出错时，给变量另外赋值
	}
	yield second + 3;
}
let iterator = createIterator();
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next(4)); // "{ value: 6, done: false }"
console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }"    throw()方法就像next()方法一样返回了一个结果对象。
console.log(iterator.next()); // "{ value: undefined, done: true }"
{% endcodeblock %}
next()方法指示迭代器继续执行（可能会带着给定的值），而throw()方法则指示迭代器通过抛出一个错误继续执行。在调用点之后会发生什么，根据生成器内部的代码来决定。
3.生成器的Return语句
由于生成器是函数，你可以在它内部使用return语句，既可以让生成器早一点退出执行，也可以指定在next()方法最后一次调用时的返回值。在return语句中指定的任意值都只会在结果对象中出现一次，此后value字段就会被重置为undefined。
扩展运算符与for-of循环会忽略return语句所指定的任意值。一旦它们看到done的值为true，它们就会停止操作而不会读取对应的value值。不过，在生成器进行委托时，迭代器的返回值会非常有用。
4.生成器委托
生成器可以用星号（*）配合yield这一特殊形式来委托其他的迭代器。正如生成器的定义，星号出现在何处是不重要的，只要落在yield关键字与生成器函数名之间即可。生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且在执行复杂任务时会非常有用。
{% codeblock %}
function *createNumberIterator() {
	yield 1;
	yield 2;
	return 3;
}
function *createRepeatingIterator(count) {
	for (let i=0; i < count; i++) {
		yield "repeat";
	}
}
function *createCombinedIterator() {
	let result = yield *createNumberIterator();
	yield *createRepeatingIterator(result);
}
var iterator = createCombinedIterator();
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: "repeat", done: false }"
console.log(iterator.next()); // "{ value: "repeat", done: false }"
console.log(iterator.next()); // "{ value: "repeat", done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
{% endcodeblock %}
你可以直接在字符串上使用yield *（例如yield * "hello"），字符串的默认迭代器会被使用。
5.异步任务运行
{% codeblock %}
function run(taskDef) {
	// 创建迭代器，让它在别处可用
	let task = taskDef();
	// 启动任务
	let result = task.next();
	// 递归使用函数来保持对 next() 的调用
	function step() {
		// 如果还有更多要做的
		if (!result.done) {
			if (typeof result.value === "function") {
				result.value(function(err, data) {
					if (err) {
						result = task.throw(err);
						return;
					}
					result = task.next(data);
					step();
				});
			} else {
				result = task.next(result.value);
				step();
			}
		}
	}
	// 开始处理过程
	step();
}

let fs = require("fs");
function readFile(filename) {
	return function(callback) {
		fs.readFile(filename, callback);
	};
}

run(function*() {
	let contents = yield readFile("config.json");
	doSomethingWith(contents);
	console.log("Done");
});
{% endcodeblock %}
当然，这些范例中所使用的模式也有缺点：你无法完全确认一个能返回函数的函数是异步的。promise 提供了更强有力的方式来调度异步任务。

### js中的类

#### 类
1.类声明以class关键字开始，其后是类的名称；剩余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。
2. 类表达式被设计用于变量声明，或可作为参数传递给函数。类表达式不需要在class关键字后使用标识符。除了语法差异，类表达式的功能等价于类声明。
{% codeblock %}
class PersonClass {          //类声明
//let PersonClass = class {  //匿名的类表达式
//let PersonClass = class PersonClass2 {   //具名类表达式
	// 等价于 PersonType 构造器
	constructor(name) {
		this.name = name;
	}
	// 等价于 PersonType.prototype.sayName
	sayName() {
		console.log(this.name);
	}
}
let person = new PersonClass("Nicholas");
person.sayName(); // 输出 "Nicholas"
console.log(person instanceof PersonClass); // true
console.log(person instanceof Object); // true
console.log(typeof PersonClass); // "function"
console.log(typeof PersonClass.prototype.sayName); // "function"
{% endcodeblock %}

#### 类与自定义类型之间的区别
1. 类声明不会被提升，这与函数定义不同。类声明的行为与let相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。
2. 类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。
3. 类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用Object.defineProperty()才能将方法改变为不可枚举。
4. 类的所有方法内部都没有[[Construct]]，因此使用new来调用它们会抛出错误。
5. 调用类构造器时不使用new，会抛出错误。
6. 试图在类的方法内部重写类名，会抛出错误。只有在类的内部，类名才被视为是使用const声明的。这意味着你可以在外部重写类名，但不能在类的方法内部这么做。
{% codeblock %}
// 直接等价于 PersonClass
let PersonType2 = (function() {
	"use strict";
	const PersonType2 = function(name) {
	//const PersonClass2 = function(name) {  //具名类表达式
		// 确认函数被调用时使用了 new
		if (typeof new.target === "undefined") {
			throw new Error("Constructor must be called with new.");
		}
		this.name = name;
	}
	Object.defineProperty(PersonType2.prototype, "sayName", {
		value: function() {
		// 确认函数被调用时没有使用 new
		if (typeof new.target !== "undefined") {
			throw new Error("Method cannot be called with new.");
		}
		console.log(this.name);
		},
		enumerable: false,
		writable: true,
		configurable: true
	});
	return PersonType2;
}());
{% endcodeblock %}

#### 作为一级公民的类
1.在编程中，能被当作值来使用的就称为一级公民（first-class citizen），意味着它能作为参数传给函数、能作为函数返回值、能用来给变量赋值。
2.类表达式的另一个有趣用途是立即调用类构造器，以创建单例（Singleton）。为此，你必须使用new来配合类表达式，并在表达式后面添加括号。
{% codeblock %}
let person = new class {
	constructor(name) {
		this.name = name;
	}
	sayName() {
		console.log(this.name);
	}
}("Nicholas");
person.sayName(); // "Nicholas"
{% endcodeblock %}

#### 访问器属性
自有属性需要在类构造器中创建，而类还允许你在原型上定义访问器属性(不可枚举)。为了创建一个getter，要使用get关键字，并要与后方标识符之间留出空格；创建setter用相同方式，只是要换用set关键字。
{% codeblock %}
class CustomHTMLElement {
	constructor(element) {
		this.element = element;
	}
	get html() {
		return this.element.innerHTML;
	}
	set html(value) {
		this.element.innerHTML = value;
	}
}
var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html");
console.log("get" in descriptor); // true
console.log("set" in descriptor); // true
console.log(descriptor.enumerable); // false

// 直接等价于上个范例
let CustomHTMLElement = (function() {
	"use strict";
	const CustomHTMLElement = function(element) {
		// 确认函数被调用时使用了 new
		if (typeof new.target === "undefined") {
			throw new Error("Constructor must be called with new.");
		}
		this.element = element;
	}
	Object.defineProperty(CustomHTMLElement.prototype, "html", {
		enumerable: false,
		configurable: true,
		get: function() {
			return this.element.innerHTML;
		},
		set: function(value) {
			this.element.innerHTML = value;
		}
	});
	return CustomHTMLElement;
}());
{% endcodeblock %}

#### 需计算的成员名
类方法与类访问器属性也都能使用需计算的名称。语法相同于对象字面量中的需计算名称：无须使用标识符，而是用方括号来包裹一个表达式。
{% codeblock %}
let methodName = "sayName";
let propertyName = "html";
class PersonClass {
	constructor(name) {
		this.name = name;
	}
	[methodName]() {
		console.log(this.name);
	}
	get [propertyName]() {
		return this.element.innerHTML;
	}
	set [propertyName](value) {
		this.element.innerHTML = value;
	}
}
let me = new PersonClass("Nicholas");
me.sayName(); // "Nicholas"
{% endcodeblock %}

#### 生成器方法
只要在方法名称前附加一个星号（*）。这一语法对类同样有效，允许将任何方法变为一个生成器。你可以使用Symbol.iterator来定义生成器方法，从而定义出类的默认迭代器。
{% codeblock %}
class Collection {
	constructor() {
		this.items = [];
	}
	*[Symbol.iterator]() {
		yield *this.items.values();
	}
}
var collection = new Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);
for (let x of collection) {
	console.log(x);
}
// 输出：
// 1
// 2
// 3
{% endcodeblock %}
当你想让方法与访问器属性在对象实例上出现时，把它们添加到类的原型上就会对此目的有帮助。而另一方面，若想让方法与访问器属性只存在于类自身，那么你就需要使用静态成员。

#### 静态成员
只要在方法与访问器属性的名称前添加正式的static标注。你能在类中的任何方法与访问器属性上使用static关键字，唯一限制是不能将它用于constructor方法的定义。静态成员不能用实例来访问，你始终需要直接用类自身来访问它们。
{% codeblock %}
class PersonClass {
	// 等价于 PersonType 构造器
	constructor(name) {
		this.name = name;
	}
	// 等价于 PersonType.prototype.sayName
	sayName() {
		console.log(this.name);
	}
	// 等价于 PersonType.create
	static create(name) {
		return new PersonClass(name);
	}
}
let person = PersonClass.create("Nicholas");
{% endcodeblock %}

#### 继承
继承了其他类的类被称为派生类（derived classes）。如果派生类指定了构造器，就需要使用super()，否则会造成错误。若你选择不使用构造器，super()方法会被自动调用，并会使用创建新实例时提供的所有参数。
1.使用super()时需牢记以下几点：
(1). 你只能在派生类中使用super()。若尝试在非派生的类（即：没有使用extends关键字的类）或函数中使用它，就会抛出错误。
(2). 在构造器中，你必须在访问this之前调用super()。由于super()负责初始化this，因此试图先访问this自然就会造成错误。
(3). 唯一能避免调用super()的办法，是从类构造器中返回一个对象。
2.派生类中的方法总是会屏蔽基类的同名方法。可以使用super.方法来调用基类中的同名方法。
3.如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。
4.只要一个表达式能够返回一个具有[[Construct]]属性以及原型的函数，你就可以对其使用extends。extends后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类。null和生成器函数不存在[[Construct]]不能在extends关键字后使用。
{% codeblock %}
function Rectangle(length, width) {
	this.length = length;
	this.width = width;
}
Rectangle.prototype.getArea = function() {
	return this.length * this.width;
};
function getBase() {
	return Rectangle;
}
class Square extends getBase() {
	constructor(length) {
		super(length, length);
	}
}
var x = new Square(3);
console.log(x.getArea()); // 9
console.log(x instanceof Rectangle); // true
{% endcodeblock %}
5.继承内置对象
在ES5的传统继承中，this的值会先被派生类（例如MyArray）创建，随后基类构造器（例如Array.apply()方法）才被调用。这意味着this一开始就是MyArray的实例，之后才使用了Array的附加属性对其进行了装饰。
在ES6基于类的继承中，this的值会先被基类（Array）创建，随后才被派生类的构造器（MyArray）所修改。结果是this初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。
6.Symbol.species 属性
一般而言，每当想在类方法中使用this.constructor时，你就应当设置类的Symbol.species属性。这么做允许派生类轻易地重写方法的返回类型。此外，若你从一个拥有Symbol.species定义的类创建了派生类，要保证使用此属性，而不是直接使用构造器。
{% codeblock %}
class MyArray extends Array {
	// 空代码块
}
let items = new MyArray(1, 2, 3, 4),
subitems = items.slice(1, 3);
console.log(items instanceof MyArray); // true
console.log(subitems instanceof MyArray); // true

class MyArray extends Array {
	static get [Symbol.species]() {   //只有getter而没有setter，这是因为修改类的species是不允许的。
		return Array;
	}
}
let items = new MyArray(1, 2, 3, 4),
subitems = items.slice(1, 3);
console.log(items instanceof MyArray); // true
console.log(subitems instanceof Array); // true
console.log(subitems instanceof MyArray); // fals
{% endcodeblock %}
#### 在类构造器中使用new.target
1.在类构造器中使用new.target，来判断类是被如何被调用的
(1)在简单情况下，new.target就等于本类的构造器函数
(2)因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用new.target来创建一个抽象基类（一种不能被实例化的类）
{% codeblock %}
// 静态的基类
class Shape {
	constructor() {
		if (new.target === Shape) {
			throw new Error("This class cannot be instantiated directly.")
		}
	}
}
class Rectangle extends Shape {
	constructor(length, width) {
		super();
		this.length = length;
		this.width = width;
	}
}
var x = new Shape(); // 抛出错误
var y = new Rectangle(3, 4); // 没有错误
console.log(y instanceof Shape); // true
{% endcodeblock %}
(3)由于调用类时不能缺少new，于是new.target属性在类构造器内部就绝不会是undefined。

### 增强的数组功能

#### 创建数组
1.Array.of()方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。
2.Array.from():
(1)将可迭代对象或者类数组对象作为第一个参数传入，Array.from()就能返回一个数组。
(2)向Array.from()方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。
(3)传递第三个参数给Array.from()方法，指定映射函数内部的this值。
{% codeblock %}
let helper = {
	diff: 1,
	add(value) {
		return value + this.diff;
	}
};
function translate() {
	return Array.from(arguments, helper.add, helper);
}
let numbers = translate(1, 2, 3);
console.log(numbers); // 2,3,4
{% endcodeblock %}

#### 所有数组上的新方法
1.find() 与 findIndex()
(1)ES5增加了indexOf()与lastIndexOf()方法，从而允许开发者在数组中查找特定值。
find()与findIndex()方法在查找满足特定条件的数组元素时非常有用。
(2)find()与findIndex()方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的this。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身，这与map()和forEach()方法的回调函数所用的参数一致。该回调函数应当在给定的元素满足你定义的条件时返回true，而find()与findIndex()方法均会在回调函数第一次返回true时停止查找。二者唯一的区别是：find()方法会返回匹配的值，而findIndex()方法则会返回匹配位置的索引。
2.fill()方法
fill()方法能使用特定值填充数组中的一个或多个元素。当只使用一个参数的时候，该方法会用该参数的值填充整个数组。第二个参数指定填充的起始位置，第三个参数指定填充的结束位置（不包括结束位置的那个元素）。如果提供的起始位置或结束位置为负数，则它们会被加上数组的长度来算出最终的位置。
3.copyWithin()方法
copyWithin()方法允许你在数组内部复制自身元素。第一个参数从什么位置开始进行填充，第二个参数被用来复制的数据的起始位置索引，第三个参数指定了复制停止的位置（不包含该位置自身）。如果传递负数参数，数组的长度会自动被加到该参数的值上，以便算出正确的索引位置。

#### 类型化数组
类型化数组是有特殊用途的数组，被设计用来处理数值类型数据。

##### 数值数据类型
1. 8 位有符号整数（int8）
2. 8 位无符号整数（uint8）
3. 16 位有符号整数（int16）
4. 16 位无符号整数（uint16）
5. 32 位有符号整数（int32）
6. 32 位无符号整数（uint32）
7. 32 位浮点数（float32）
8. 64 位浮点数（float64）
为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。

##### 数组缓冲区
数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。数组缓冲区总是保持创建时指定的字节数，你可以修改其内部的数据，但永远不能修改它的容量。
1.调用ArrayBuffer构造器时，只需要传入单个数值用于指定缓冲区包含的字节数。
2.当数组缓冲区被创建完毕后，你就可以通过检查byteLength属性来获取缓冲区的字节数。
{% codeblock %}
let buffer = new ArrayBuffer(10); // 分配了10个字节
console.log(buffer.byteLength); // 10
{% endcodeblock %}
3.还可以使用slice()方法来创建一个新的、包含已有缓冲区部分内容的数组缓冲区。该slice()方法类似于数组上的同名方法，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。
为了写入数据，你需要创建一个视图（view）

##### 使用视图操作数组缓冲区
1.数组缓冲区代表了一块内存区域，而视图（views）则是你操作这块区域的接口。视图工作在数组缓冲区或其子集上，可以读写某种数值数据类型的数据。DataView类型是数组缓冲区的通用视图，允许你对前述所有八种数值数据类型进行操作。
2.也可以在缓冲区的一个部分上创建视图，只需要指定可选参数——字节偏移量、以及所要包含的字节数。当未提供最后一个参数时，该DataView视图会默认包含从偏移位置开始、到缓冲区末尾为止的元素。使用这种方式，你可以在同一个数组缓冲区上创建多个不同的视图，这样有助于将单块内存区域供给整个应用使用，而不必每次在有需要时才动态分配内存。
{% codeblock %}
let buffer = new ArrayBuffer(10),
view = new DataView(buffer, 5, 2); // 包含位置 5 与位置 6 的字节
{% endcodeblock %}
3.获取视图信息
(1)buffer：该视图所绑定的数组缓冲区；
(2)byteOffset：传给DataView构造器的第二个参数，如果当时提供了的话（默认值为0）;
(3)byteLength：传给DataView构造器的第三个参数，如果当时提供了的话（默认值为该缓冲区的byteLength属性）。
{% codeblock %}
let buffer = new ArrayBuffer(10),
view1 = new DataView(buffer), // 包含所有字节
view2 = new DataView(buffer, 5, 2); // 包含位置 5 与位置 6 的字节
console.log(view1.buffer === buffer); // true
console.log(view2.buffer === buffer); // true
console.log(view1.byteOffset); // 0
console.log(view2.byteOffset); // 5
console.log(view1.byteLength); // 10
console.log(view2.byteLength); // 2
{% endcodeblock %}
4.读取与写入数据(int8或uint8为例，8可以替换为16或32)
“get”方法接受两个参数：开始进行读取的字节偏移量、以及一个可选的布尔值，后者用于指定读取的值是否采用低字节优先方式（注：默认值为  false  ）。“set”方法则接受三个参数：开始进行写入的字节偏移量、需要写入的数据值、以及一个可选的布尔值用于指定是否采用低字节优先方式存储数据
低字节优先（Little-endian）也被翻译作“小端字节序”，指的是在存储数据的多个内存字节中，第一个内存字节存储着数据的最低字节数据，而最后一个内存字节存储着最高字节数据。
(1)getInt8(byteOffset, littleEndian) ：从byteOffset处开始读取一个 int8 值；
(2)setInt8(byteOffset, value, littleEndian) ：从byteOffset处开始写入一个 int8 值；
(3)getUint8(byteOffset, littleEndian) ：从byteOffset处开始读取一个无符号 int8 值；
(4)setUint8(byteOffset, value, littleEndian) ：从byteOffset处开始写入一个无符号int8值。

DataView提供的方法
getFloat32(byteOffset, littleEndian) ：从byteOffset处开始读取一个 32 位的浮点数；
setFloat32(byteOffset, value, littleEndian) ：从byteOffset处开始写入一个 32 位的浮点数；
getFloat64(byteOffset, littleEndian) ：从byteOffset处开始读取一个 64 位的浮点数；
setFloat64(byteOffset, value, littleEndian) ：从byteOffset处开始写入一个 64 位的浮点数。
{% codeblock %}
let buffer = new ArrayBuffer(2),
view = new DataView(buffer);
view.setInt8(0, 5);
view.setInt8(1, -1);
console.log(view.getInt8(0)); // 5
console.log(view.getInt8(1)); // -1
{% endcodeblock %}

视图允许你使用任意格式对任意位置进行读写，而无须考虑这些数据此前是使用什么格式存储的。
{% codeblock %}
let buffer = new ArrayBuffer(2),
view = new DataView(buffer);
view.setInt8(0, 5);
view.setInt8(1, -1);
console.log(view.getInt16(0)); // 1535
console.log(view.getInt8(0)); // 5
console.log(view.getInt8(1)); // -1
{% endcodeblock %}

##### 类型化数组即为视图
1.ES6 的类型化数组实际上也是针对数组缓冲区的特定类型视图，你可以使用这些数组对象来处理特定的数据类型，而不必使用通用的DataView对象。一共存在八种特定类型视图，对应着八种数值数据类型，为处理uint8值提供了额外的选择。
2.Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array
3.类型化数组只能在特定的一种数据类型上工作，例如：Int8Array的所有操作都只能处理int8值。类型化数组的元素可以使用数值型的索引位置来访问，就像常规数组那样，从而规避了使用DataView存取方法时的某些尴尬情况。
4.创建特定类型视图
(1)第一种方式是使用与创建DataView时相同的参数，即：一个数组缓冲区、一个可选的字节偏移量、以及一个可选的字节数量。
{% codeblock %}
let buffer = new ArrayBuffer(10),
	view1 = new Int8Array(buffer),
	view2 = new Int8Array(buffer, 5, 2);
console.log(view1.buffer === buffer); // true
console.log(view2.buffer === buffer); // true
console.log(view1.byteOffset); // 0
console.log(view2.byteOffset); // 5
console.log(view1.byteLength); // 10
console.log(view2.byteLength); // 2
{% endcodeblock %}
(2)第二种方式是传递单个数值给类型化数组的构造器，此数值表示该数组包含的元素数量（而不是分配的字节数）。构造器将会创建一个新的缓冲区，分配正确的字节数以便容纳指定数量的数组元素，而你也可以使用length属性来获取这个元素数量。
如果调用类型化数组构造器时没有传入参数，构造器会认为传入了0，这种方式创建的类型化数组不会被分配任何存储空间，因此也就不能被用于保存数据。
{% codeblock %}
let ints = new Int16Array(2),
	floats = new Float32Array(5);
console.log(ints.byteLength); // 4
console.log(ints.length); // 2
console.log(floats.byteLength); // 20
console.log(floats.length); // 5
{% endcodeblock %}
(3)第三种方式是向构造器传递单个对象参数，可以是下列四种对象之一：
  类型化数组：数组所有元素都会被复制到新的类型化数组中。例如，如果你传递一个int8类型的数组给Int16Array构造器，这些int8的值会被复制到int16数组中。新的类型化数组与原先的类型化数组会使用不同的数组缓冲区。
  可迭代对象：该对象的迭代器会被调用以便将数据插入到类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。
  数组：该数组的元素会被插入到新的类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。
  类数组对象：与传入数组的表现一致。
新的类型化数组都会从原对象获取数据。若想用一些值来初始化一个类型化数组，这种方式就特别有用，
{% codeblock %}
let ints1 = new Int16Array([25, 50]),
	ints2 = new Int32Array(ints1);
console.log(ints1.buffer === ints2.buffer); // false
console.log(ints1.byteLength); // 4
console.log(ints1.length); // 2
console.log(ints1[0]); // 25
console.log(ints1[1]); // 50
console.log(ints2.byteLength); // 8
console.log(ints2.length); // 2
console.log(ints2[0]); // 25
console.log(ints2[1]); // 50
{% endcodeblock %}
##### 类型化数组与常规数组的相似点
1.类型化数组在很多场景中都可以像常规数组那样被使用。例如可以使用length属性来获取类型化数组包含的元素数量，还可以使用数值类型的索引值来直接访问类型化数组的元素。与常规数组不同的是，你不能使用length属性来改变类型化数组的大小。该属性是不可写的，在非严格模式下写入操作会被忽略，而严格模式下则会抛出错误。
{% codeblock %}
let ints = new Int16Array([25, 50]);
console.log(ints.length); // 2
console.log(ints[0]); // 25
console.log(ints[1]); // 50
ints[0] = 1;
ints[1] = 2;
console.log(ints[0]); // 1
console.log(ints[1]); // 2
/*
这段代码创建了一个包含两个元素的Int16Array，使用数值类型的索引可以读写对应的项，而数值在存储时会被自动转换为int16类型的值。
*/
{% endcodeblock %}
2.公共方法
copyWithin() entries() fill() filter() find() findIndex() forEach() indexOf() join() keys() lastIndexOf() map() reduce() reduceRight() reverse() slice() some() sort() values()
类型化数组的方法会进行额外的类型检查以确保安全，并且返回值会是某种类型化数组，而不是常规数组（归结于Symbol.species属性）。
3.相同的迭代器
与常规数组相同，类型化数组也拥有三个迭代器，它们是entries()方法、keys()方法与values() 方法。这就意味着你可以对类型化数组使用扩展运算符，或者对其使用for-of循环，就像对待常规数组。
借助扩展运算符能轻易地将类型化数组转换为常规数组，就像处理其他可迭代对象那样。
3.of()与from()方法
所有的类型化数组都包含静态的of()与from()方法，作用类似于Array.of()与Array.from()方法。其中的区别是类型化数组的版本会返回类型化数组，而不返回常规数组。
{% codeblock %}
let ints = Int16Array.of(25, 50),
	floats = Float32Array.from([1.5, 2.5]);
console.log(ints instanceof Int16Array); // true
console.log(floats instanceof Float32Array); // true
console.log(ints.length); // 2
console.log(ints[0]); // 25
console.log(ints[1]); // 50
console.log(floats.length); // 2
console.log(floats[0]); // 1.5
console.log(floats[1]); // 2.5
{% endcodeblock %}

##### 类型化数组与常规数组的区别
1.二者最重要的区别就是类型化数组并不是常规数组，类型化数组并不是从Array对象派生的，使用Array.isArray()去检测会返回false。
2.常规数组可以被伸展或是收缩，然而类型化数组却会始终保持自身大小不变。你可以对常规数组一个不存在的索引位置进行赋值，但在类型化数组上这么做则会被忽略。
3.类型化数组也会对数据类型进行检查以保证只使用有效的值，当无效的值被传入时，将会被替换为0。所有在类型化数组上修改项目值的方法都会受到相同的限制，例如当map()方法使用的映射函数返回一个无效值的时候，类型化数组会使用0来代替返回值。多亏这种纠错行为，类型化数组的内容永远不会是无效值，因此相关方法就无须再担心传入无效值会导致错误。
4.类型化数组没有concat() pop() push() shift() splice() unshift()方法。除了concat()方法之外，该列表中的其余方法都会改变数组的大小，而由于类型化数组的大小不可变，因此这些方法都不能作用于类型化数组。concat()方法不可用的原因则是：连接两个类型化数组的结果是不确定的（特别是当它们处理的数据类型不同时），这种不确定情况原本就不应当使用类型化数组。
5.类型化数组还有两个常规数组所不具备的方法：set()方法与subarray()方法。这两个方法作用相反：set()方法从另一个数组中复制元素到当前的类型化数组，而subarray()方法则是将当前类型化数组的一部分提取为新的类型化数组。
(1)set()方法接受一个数组参数（无论是类型化的还是常规的）、以及一个可选的偏移量参数，后者指示了从什么位置开始插入数据（默认值为0）。数组参数中的数据会被复制到目标类型化数组中，并会确保数据值有效。
{% codeblock %}
let ints = new Int16Array(4);
ints.set([25, 50]);
ints.set([75, 100], 2);
console.log(ints.toString()); // 25,50,75,100
{% endcodeblock %}
(2)subarray()方法接受一个可选的开始位置索引参数、以及一个可选的结束位置索引参数（像slice()方法一样，结束位置的元素不会被包含在结果中），并会返回一个新的类型化数组。你可以同时省略这两个参数，从而创建原类型化数组的一个复制品。
{% codeblock %}
let ints = new Int16Array([25, 50, 75, 100]),
	subints1 = ints.subarray(),
	subints2 = ints.subarray(2),
	subints3 = ints.subarray(1, 3);
console.log(subints1.toString()); // 25,50,75,100
console.log(subints2.toString()); // 75,100
console.log(subints3.toString()); // 50,75
{% endcodeblock %}
